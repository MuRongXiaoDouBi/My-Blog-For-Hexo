{"pages":[{"title":"","text":"关于我 微信：g520cong | 邮箱：admin@imuboy.cn Github: https://github.com/MuRongXiaoDouBi 当前状态：2020应届生 | 求职意向：web前端工程师 学校：潍坊学院 | 专业：网络工程 | 学历：统招本科 专业技能 熟练掌握HTML(5)和常用CSS(3)，具有像素级还原设计稿的能力。具有平均水准之上的审美，追求设计的优雅。 熟练掌握原生Javascript，掌握重要概念如： 原型，闭包，作用域链等。熟练使用ES6及ES7部分新特性。 熟练使用Vue及Vue全家桶进行开发，了解React。 熟悉Yarn &amp; Npm &amp; Git ，能够使用Node.js搭配Koa.Js进行基本后台开发。 熟悉CMD &amp; AMD机制，了解Webpack打包，优化手段。 了解HTTP协议及浏览器渲染原理，了解前端性能优化策略。 追求风格优雅，整洁的代码。 工作经历潍坊 ** 智能科技有限公司 - Web前端开发 研发部2019.08 - 至今 短视频直播平台 负责后台管理系统开发，基于webpack构建vue项目，使用ElementUI进行开发，Git版本控制 由于原系统性能与体验相对较差，独立负责进行代码重构，优化首页白屏时间，优化接口请求量。 合理利用前端组件化思维，将细节化功能抽象成可复用组件。 使用webpack与cdn等技术进行优化，在该系统上线后，白屏时间从8 ~ 10秒优化到2 ~ 3秒，提升用户体验。 使用mixin抽出高重复代码，提升逻辑复用性。 疫情数据可视化驾驶舱 负责可视化地图制作，基于webpack构建vue项目，完成地图三级下钻功能，省市级地图数据分层，县级散点地图。 负责疫情管理后台制作，控制硬件扫描设备完成人像模板记录。 潍坊 ** 科技有限公司 - Web前端开发2019.02 - 2019.07 智能农业微信小程序 基于Mpvue构建项目，根据UI设计稿封装UI组件，提升用户体验。 微物流微信小程序 使用VantUI库开发，提升开发效率与用户体验。 书院听书小程序 完成看书、听书、搜索功能开发，对搜索功能使用函数节流，提升性能。 开源项目及个人作品基于TypeScript与Koa的cms框架Github地址：https://github.com/MuRongXiaoDouBi/koa-typescript-cms Koa全家桶：Koa、Koa-router、koa-bodyparser ORM框架：sequelize、sequelize-typescript、mysql2 参数校验：validator、class-validator 其他：validator、class-validator等等 使用TypeScript与koa构建的简单cms框架，具有路由自动注册、全局异常处理、参数校验、JWT鉴权、权限管理、用户管理等 cms基础功能。","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"ASCII码排序（Go）","text":"Problem Description ： 输入三个字符后，按各字符的ASCII码从小到大的顺序输出这三个字符。Input ： 输入数据有多组，每组占一行，有三个字符组成，之间无空格。Output ： 对于每组输入数据，输出一行，字符中间用一个空格分开。Sample Input ： qwe/asd/zxcSample Output ： e q w/a d s/c x z 1234567891011121314151617181920212223func sort(arr []int32) []int32 { for i := 0; i &lt;= len(arr); i++ { for j := i + 1; j &lt;= len(arr)-1; j++ { if arr[i] &gt; arr[j] { temp := arr[j] arr[j] = arr[i] arr[i] = temp } } } return arr}func main() { var input string fmt.Printf(\"请输入三个英文字符：\") _, _ = fmt.Scan(&amp;input) var asclls = []int32(input) result := sort(asclls) for _, v := range result { fmt.Printf(\"%v \", string(v)) }}","link":"/2020/09/28/ASCII%E7%A0%81%E6%8E%92%E5%BA%8F%EF%BC%88Go%EF%BC%89/"},{"title":"JS-Web-API（一）：DOM与BOM","text":"DOMDOM的本质DOM的本质是从html文件解析出来的树状数据结构 DOM节点操作获取DOM节点1234const div1 = document.getElementById('div1') // 获取一个元素const divList = document.getElementsByTagName('div') // 获取一个元素集合const containerList = document.getElementsByClassName('.container') // 集合const pList = document.querySelectorAll('p') // 集合 DOM节点的property123456789101112const pList = document.querySelectorAll('p') // 获取一个元素集合const p = pList[0] // 获取第一个元素console.log(p.style.width) // 获取样式p.style.width = '100px' // 修改样式console.log(p.className) // 获取classp.className = 'p1' // 修改class// 获取nodeName和nodeTypeconsole.log(p.nodeName)console.log(p.nodeType) DOM节点的attribute12345678const pList = document.querySelectorAll('p') // 获取一个元素集合const p = pList[0] // 获取第一个元素p.getAttribute('data-name') // 获取data-name属性p.setAttribute('data-name', 'abc') // 设置data-name属性的值为abcp.getAttribute('style') // 获取style属性p.setAttribute('style', 'font-size:30px;') // 设置style属性的值为font-size:30px; DOM节点操作总结 property：修改DOM对象属性，不会体现到html结构中 attribute：修改html属性，会改变html结构 两者都有可能引起DOM重新渲染 DOM结构操作新增/插入节点12345678const div1 = document.getElementById('div1')// 添加新节点const p1 = document.createElement('p')p1.innerHTML = 'this is p1'div1.appendChild(p1) // 添加新创建的元素// 移动已有节点，注意是移动！！！将DOM移动到指定节点中const p2 = document.getElementById('p2')div1.appendChild(p2) 获取父/子元素1234567const div1 = document.getElementById('div1')// 添加新节点const p1 = document.createElement('p')p1.innerHTML = 'this is p1'div1.appendChild(p1) // 添加新创建的元素console.log(p1.parentNode) // 获取父元素console.log(div1.childNodes) // 获取子元素列表 删除子元素123456const div1 = document.getElementById('div1')// 添加新节点const p1 = document.createElement('p')p1.innerHTML = 'this is p1'div1.appendChild(p1) // 添加新创建的元素div1.removeChild(div1.childNodes[0]) DOM性能 DOM操作非常“昂贵”，避免频繁操作DOM 对DOM查询做缓存，可以减少DOM操作 将频繁操作改为一次性操作 对DOM查询做缓存1234567891011// 不缓存DOM查询结果for(let i = 0; i &lt; document.getElementsByTagName('p').length; i++) { // 每次循环，都会计算length，频繁进行DOM查询}// 缓存DOM查询结果const pList = document.getElementsByTagName('p')const length = pList.lengthfor(let i = 0; i &lt; length; i++) { // 缓存length，只进行一次DOM查询} 将频繁操作改为一次性操作1234567891011121314const listNode = document.getElementById('list')// 创建一个文档片段，此时还没有插入到DOM树中const frag = document.createDocumentFragment()// 执行插入for(let i = 0; i &lt; 10; i++) { const li = document.createElement('li') li.innerHTML = 'list item ' + i frag.appendChild(li)}// 都完成之后，再插入到DOM树中listNode.appendChild(frag) BOMnavigator和screen123456789// navigatorconst ua = navigator.userAgent// 识别浏览器类型const isChrome = ua.indexOf('Chrome')console.log(isChrome)// screenconsole.log(screen.width) // 屏幕宽度console.log(screen.height) // 屏幕高度 location和history123456789101112// location// 拆解url各个部分console.log(location.href) // 获取当前网址console.log(location.protocol) // 获取当前网址协议console.log(location.host) // 获取当前主机地址console.log(location.search) // 获取当前网址中的参数console.log(location.hash) // 获取当前网址中的哈希console.log(location.pathname) // 获取当前网址中的路径// historyhistory.back() // 后退history.forward() // 前进","link":"/2020/03/06/JS-Web-API%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ADOM%E4%B8%8EBOM/"},{"title":"JS-Web-API（三）：Ajax","text":"XMLHttpRequestGET请求123456789101112131415// 初始化实例const xhr = new XMLHttpRequest()// 第三个参数true则为异步xhr.open('GET','url', true)xhr.onreadystatechange = function () { // 这里函数异步执行 if (xhr.readyState === 4) { if (xhr.statusCode === 200) { console.log(xhr.responseText) } else { console.log('请求失败') } }}xhr.send() POST请求12345678910111213141516171819// 初始化实例const xhr = new XMLHttpRequest()// 第三个参数true则为异步xhr.open('POST','url', true)xhr.onreadystatechange = function () { // 这里函数异步执行 if (xhr.readyState === 4) { if (xhr.statusCode === 200) { console.log(xhr.responseText) } else { console.log('请求失败') } }}const postData = JSON.stringify({ a: 1})// 发送数据xhr.send(postData) readyState 0 - 未初始化（还没调用send()方法） 1 - 载入（已调用send()方法，正在发送请求） 2 - 载入完成（send()方法执行完成，已经接收到全部相应内容） 3 - 交互（正在解析相应内容） 4 - 完成（相应内容解析完成，可以再客户端调用） status 1xx - 临时响应并需要请求者继续执行操作 2xx - 成功处理请求，比如200 3xx - 重定向，浏览器直接跳转，如301 302 304 4xx - 客户端请求错误，如404 403 5xx - 服务器错误 同源策略与跨域同源策略 ajax请求时， 浏览器要求 当前网页和server必须同源（安全） 同源：协议、域名、端口， 三者必须一致 加载图片、css、js文件可无视同源策略 跨域 所有的跨域，都必须经过server端允许与配合 未经server端允许就实现跨域，说明浏览器有漏洞，危险信号 jsonp和corsjsonp script标签可绕过跨域限制 服务端可以任意动态拼接数据返回 script标签可以获得跨域的数据，只要服务端愿意返回 12345678910&lt;script src=\"xxx/getData.js\"&gt;&lt;/script&gt;&lt;!--返回一个方法 callback({a:1,b:2}) --&gt;&lt;script&gt; // 调用返回的方法 window.callback = function(data) { // 这里得到跨域的数据 console.log(data) }&lt;/script&gt; cors 服务器设置http header 1234567// 第二个参数填写允许跨域的域名，不建议直接填写 “*”response.setHeader(\"Access-Control-Allow-Origin\", \"http://localhost:8011\");response.setHeader(\"Access-Control-Allow-Headers\", \"X-Requested-With\");response.setHeader(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\");// 接收跨域的cookieresponse.setHeader(\"Access-Control-Allow-Credentials\", \"true\") 使用Promise封装一个简易Ajax123456789101112131415161718function Request(url, method, data) { return new Promise((resolve, reject) =&gt; { const xhr = new XMLHttpRequest() xhr.open(method, url, true) xhr.onreadystatechange = function() { if (xhr.readyState === 4) { if (xhr.status === 200) { resolve(JSON.parse(xhr.responseText)) } else if(xhr.status === 404) { reject(new Error('404 not Found')) } else { reject(JSON.parse(xhr.responseText)) } } } xhr.send(JSON.stringify(data)) })}","link":"/2020/03/08/JS-Web-API%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AAjax/"},{"title":"JS-Web-API（二）：事件","text":"事件绑定1234const btn = document.getElementById('btn1')btn.addEventListener('click', event =&gt; { console.log('clicked')}) 12345678910// 通用的绑定函数function bindEvent(elem, type, fn) { elem.addEventListener(type, fn)}const a = document.getElementById('link1')bindEvent(a, 'click', e =&gt; { e.preventDefault() // 阻止默认行为 alert('clicked')}) 事件冒泡 事件冒泡会顺着出发元素由DOM结构从内至外进行事件响应 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;body&gt; &lt;div id=\"div1\"&gt; &lt;p id=\"p1\"&gt;激活&lt;/div&gt; &lt;p id=\"p2\"&gt;取消&lt;/div&gt; &lt;/div&gt; &lt;div id=\"div2\"&gt; &lt;p id=\"p3\"&gt;取消&lt;/div&gt; &lt;p id=\"p4\"&gt;取消&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; const body = document.body const p1 = document.getElementById('p1') // 引用上面封装的方法 bindEvent(p1, 'click', e =&gt; { console.log('激活') }) bindEvent(body, 'click', e =&gt; { console.log('取消') }) // 点击p1区域输出 // 激活 取消 // 点击body除p1区域输出 // 取消 // 阻止事件冒泡 bindEvent(p1, 'click', e =&gt; { // 阻止默认行为 e.stopPropagation() console.log('激活') }) // 点击p1区域输出 // 激活 // 点击body除p1区域输出 // 取消&lt;/script&gt; 事件代理 代码简洁 减少浏览器内存占用 不要滥用 代理绑定12345678910111213141516171819202122232425&lt;!--在不确定元素数量的情况下使用事件代理--&gt;&lt;body&gt; &lt;div id=\"div1\"&gt; &lt;a href=\"#\"&gt;a1&lt;/a&gt; &lt;a href=\"#\"&gt;a2&lt;/a&gt; &lt;a href=\"#\"&gt;a3&lt;/a&gt; .... &lt;/div&gt;&lt;/body&gt;&lt;script&gt; const div1 = document.getElementById('div1') // 事件代理 bindEvent(div1, 'click', e =&gt; { // 阻止默认行为 e.stopPropagation() const target = event.target if (target.nodeName === 'A') { console.log(target.innerHTML) } }) // 点击a1 打印a1 // 点击a2 打印a2 // ....&lt;/script&gt; 更全面的通用绑定函数12345678910111213141516171819202122232425function bindEvent(elem, type, selector, fn) { // 如果第四个参数不存在 // 匹配bindEvent(div1, 'click', function(e) {})的情况 if (fn == null) { fn = selector selector = null } elem.addEventListener(type, event =&gt; { const target = event.target // 代理绑定 if(selector) { // 判断当前target是否为指定的元素 if (target.matches(selector)) { // 绑定this fn.call(target, event) } } else { // 普通绑定 // 绑定this fn.call(target, event) } })}","link":"/2020/03/08/JS-Web-API%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6/"},{"title":"JS基础知识（一）：变量类型和计算","text":"值类型和引用类型值类型值类型示例12345// 值类型let a = 100let b = aa = 200console.log(b) // 100 值类型在内存中的存储方式 值类型一般都是在栈中存储一个值 栈 key value a 100 ... ... 栈 key value a 100 b 100 栈 key value a 200 b 100 常见值类型12345678// const意为定义一个常量// const定义的变量必须赋值，不然会报错// 这里使用let定义a变量let a // undefinedconst s = 'abc'const n = 100const b = trueconst s = Symbol('s') 引用类型引用类型示例12345// 引用类型let a = { age: 20 }let b = ab.age = 21console.log(a.age) // 21 引用类型在内存中的存储方式 变量在计算机中存储时，栈和堆是同时存在的，栈是从上至下累加，堆是从下至上累加。引用类型会在堆中申请一个内存地址，将变量的值存储在堆里。栈中存储的不在是一个值，而是对应堆的内存地址。为什么引用类型不将值直接存储在栈中？原因还是性能问题，引用类型值的占用空间比值类型大的多，无论是存储还是引用，都会导致速度非常慢。 栈 key value a 内存地址1 ... ... 栈 key value a 内存地址1 b 内存地址1 栈 key value a 内存地址1 b 内存地址1 ... ... 内存地址1 {age:20} key value 堆 ... ... 内存地址1 {age:20} key value 堆 ... ... 内存地址1 {age:21} key value 堆 常见引用类型123456const obj = { x: 100 }const arr = ['a','b', 'c']const n = null // 特殊引用类型，指针指向为空地址// 特殊引用类型，但不用于存储数据，所以没有”拷贝、复制函数“这一说function fn() {} typeof和深拷贝判断所有值类型123456789101112131415// 判断所有值类型typeof a; // 'undefined'typeof \"100\"; // 'string'typeof 100; // 'number'typeof true; // 'boolean'typeof Symbol(\"s\"); // 'symbol'// 判断函数typeof console.log(); // 'function'typeof function fn() {}; // 'function'// 识别引用类型（不能深入识别）typeof null; // 'object'typeof [\"a\", \"b\"]; // 'object'typeof { x: 100 }; // 'object' 深拷贝 深拷贝步骤： 先判断值类型是否为数组或对象，如果不是则直接返回被拷贝的值。 初始化返回结果，如果引用类型是数组则此次拷贝返回一个数组，如果是对象则返回一个对象。 遍历引用类型的key，保证key不是原型上的属性. 对遍历的值进行递归拷贝。 123456789101112131415161718192021222324252627function deepClone(obj = {}) { // 如果obj不是一个对象和数组，或者obj是null，则直接返回obj if (typeof obj !== \"object\" || obj == null) { return obj; } // 初始化返回结果 let result; if (obj instanceof Array) { // 如果是数组类型则返回数组 result = []; } else { // 如果是对象类型则返回对象 result = {}; } for (let key in obj) { // 保证key不是原型的属性 if (obj.hasOwnProperty(key)) { // 递归 result[key] = deepClone(obj[key]) } } // 返回结果 return result;}} 变量计算字符串拼接123const a = 100 + 10 // 110const b = 100 + '10' // '10010'const c = true + '10' // 'true10' ==运算符 == 会尝试将两边的值进行类型转换后使他们尽量相等 12345678910100 == '100' // true0 == '' // true0 == false // truefalse == '' // truenull == undefined // true// 除了 == null之外，其他一律使用 === ，例如：const obj = { x: 100 }if (obj.a == null ) {}// 相当于if (obj.a === null || obj.a === undefined) {} if语句和逻辑运算if语句 if语句判断的其实是truly变量和falsely变量 truly变量：!!a === true的变量 falsely变量：!!a === false的变量 123456789// truly变量const a = trueif (a) { // ...}const b = 100if (b) { // ...} 12345678910111213// falsely变量const c = ''if (c) { // ...}const d = nullif (d) { // ...}let eif (e) { / ...} 逻辑运算12310 &amp;&amp; 0 // 0'' || 'abc' // 'abc'!window.abc // true","link":"/2020/02/27/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AE%A1%E7%AE%97/"},{"title":"JS基础知识（三）：作用域与闭包","text":"作用域和自由变量作用域 全局作用域 函数作用域 块级作用域（ES6新增） 自由变量 一个变量在当前作用域没有定义，但被使用了 向上级作用域，一层一层寻找，直到找到为止 如果到全局作用域都没有找到，则报错xx is not defined 闭包概念闭包函数：声明在一个函数中的函数，叫做闭包函数。 闭包：内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。 特点 让外部访问函数内部变量成为可能； 局部变量会常驻在内存中； 可以避免使用全局变量，防止全局变量污染； 会造成内存泄漏（有一块内存空间被长期占用，而不被释放） 闭包的创建闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。闭包会发生内存泄漏，每次外部函数执行的时候，外部函数的引用地址不同，都会重新创建一个新的地址。但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。 闭包内存泄漏为： key = value，key 被删除了 value 常驻内存中; 局部变量闭包升级版（中间引用的变量） =&gt; 自由变量； 闭包应用的特殊情况，由两种表现： 函数作为参数被传递 函数作为返回值被返回 例： 1234567891011// 函数作为返回值function create() { let a = 100 return function () { console.log(a) }}let fn = create()let a = 200fn() // 100 12345678910function print(fn) { let a = 200 fn()}let a = 100function fn () { console.log(a)}print(fn) // 100 由上两个例子可以得出：闭包：自由变量的查找，是在函数定义的地方，向上级作用域查找，不是在执行的地方！！！ thisthis调用的几种情况： 作为普通函数调用 使用call、apply、bind 作为对象方法被调用 在class方法中被调用 箭头函数中调用 this取什么值在函数执行时确定，不是函数定义时确定 例一： 123456789function fn1() { console.log(this);}fn(); // windowfn1.call({ x: 100 }); // this指向{x:100}const fn2 = fn1.bind({ x: 200 }); // bind会返回一个新的函数fn2(); // {x:200} 例二： 123456789101112131415const zhangsan = { name: \"张三\", sayHi() { // this指向当前对象 console.log(this); }, wait() { setTimeout(function() { // this指向window // 因为此时的setTimeout这个方法作为普通函数进行执行 // 并不是作为zhangsan这个对象的方法进行执行 console.log(this); }); }}; 例三： 1234567891011121314const zhangsan = { name: \"张三\", sayHi() { // this指向当前对象 console.log(this); }, waitAgain() { setTimeout(() =&gt; { // this指向当前对象 // 箭头函数的this永远取它上级作用域的this console.log(this); }); }}; 例四： 1234567891011class People { constructor(name) { this.name = name; this.age = 20; } sayHi() { console.log(this); }}const zhangsan = new People('张三')zhangsan.sayHi() // zhangsan这个对象 手写call、apply和bindcall手写call之前，需要分析一下需要几个步骤：我们将调用方法的对象叫做A，将需要改变this的对象叫做B 判断是否传入参数，如果没有传入，那么默认为 window 给 context 添加一个临时属性，属性指向A 将 context 后面的参数取出来 将参数传入A 删除context临时添加的属性 123456789101112Function.prototype.myCall = function(context) { // 判断是否传入参数，如果没有传入，那么默认为 window context = context || window; // 给 context 添加一个属性，属性指向当前对象 context.fn = this; // 将 context 后面的参数取出来 const args = [...arguments].slice(1); // 将参数传入当前对象 const result = context.fn(args); delete context.fn; return result;}; applyapply与call差不多，只不过apply只需要传入两个参数，call可以传入无数个参数 1234567891011Function.prototype.myApply = function(context) { context = context || window; context.fn = this; // 需要判断是否存储第二个参数 // 如果存在，就将第二个参数展开 const result = arguments[1] ? context.fn(...arguments[1]) : context.fn(); delete context.fn; return result;}; bindbind与上方两个的区别是bind会返回一个函数 123456789101112131415Function.prototype.myBind = function (context) { if (typeof this !== 'function') { throw new TypeError('Error') } var _this = this var args = [...arguments].slice(1) // 返回一个函数 return function F() { // 因为返回了一个函数，我们可以 new F()，所以需要判断 if (this instanceof F) { return new _this(...args, ...arguments) } return _this.apply(context, args.concat(...arguments)) }}","link":"/2020/02/28/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/"},{"title":"JS基础知识（二）：原型与原型链","text":"class和继承类的基本使用123456789101112131415// 定义一个类class Student { constructor(name, number) { this.name = name this.numer = number } sayHi() { console.log(`姓名 ${this.name} , 学号 ${this.number}`) }}// 通过类 new 对象/实例const xiaoming = new Student('小明', 50)console.log(xiaoming.name) // 小明console.log(xiaoming.number) // 50xiaoming.sayHi() // 姓名 小明 , 学号 50 继承 子类通过extends继承父类 子类必须在构造函数里使用super()才可以使用父类的类方法或类属性 super()方法里传入的参数会传进父类的构造函数里 1234567891011121314151617181920212223242526272829303132333435363738// 定义一个父类 class People { constructor(name) { this.name = name } eat() { console.log(`${this.name}吃一下`) }}// 定义子类class Student extends People { constructor(name, number) { super(name) this.numer = number } sayHi() { console.log(`姓名 ${this.name} 学号 ${this.numer}`) }}class Teacher extends People { constructor(name, major) { super(name) this.major = major } teach() { console.log(`${this.name} 教授 ${this.major}`) }}const student = new Student('小明', 200)student.eat() // 小明吃一下student.sayHi() // 姓名 小明 学号 200const teacher = new Teacher('A老师', '数学')teacher.eat() // A老师吃一下teacher.teach() // A老师 教授 数学 原型12345678910// class实际上是函数，是ES6为我们提供的语法糖typeof People // 'function'typeof Student // 'function'// 隐式原型和显式原型console.log(student.__proto__) // 隐式原型console.log(Student.prototype) // 显式原型// 实例的隐式原型等于对应类的显式原型console.log(student.__proto__ === Student.prototype) 原型关系 每个class都有显式原型prototype 每个实例都有隐式原型proto 实例的proto指向对应class的prototype 执行规则 获取属性student.name或执行方法student.sayHi()时 先寻找自身属性和方法 如果找不到，则自动去proto中查找 原型链 每个对象都可以有一个原型proto，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找，如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找…… 这个操作被委托在整个原型链上，这个就是我们说的原型链了。原文链接：https://www.jianshu.com/p/08c07a953fa0 流程图 Object是所有class的父类 instanceof类型判断12345678student instanceof Student // truestudent instanceof People // truestudent instanceof Object // true[] instanceof Array // true[] instanceof Object // true{} instanceof Object // true 手写instanceof，步骤： 获得类型的原型 获得对象的原型 循环判断对象的类型是否等于类型的原型 如果对象的类型等于类型的原型，则返回true 如果等于null，则代表已经遍历到Object，返回false 如果以上条件都不成立，递归，顺着原型链继续判断 代码实现： 1234567891011121314function instanceof(left, right) { // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) { if (left === null) return false if (prototype === left) return true left = left.__proto__ }} 手写实现简易jQuery考虑插件和扩展性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class jQuery { constructor(selector) { const dom = document.querySelectorAll(selector); this.length = dom.length; this.selector = selector; // 将所有dom挂载到原型上 for (let i = 0; i &lt; this.length; i++) { this[i] = dom[i] } } // 获取某个dom get(index) { return this[index] } // jquery each方法 each(fn) { for (let i = 0; i &lt; this.length; i++) { fn(this[i]) } } // 监听事件 on(type, fn) { return this.each(elem =&gt; { elem.addEventListener(type, fn, false) }) }}// 插件jQuery.prototype.dialog = function (info) { console.log(info)}// 基于jQuery二次封装class myJQuery extends jQuery { constructor(selector) { super(selector) } addClass() { console.log('addClass') } add() { console.log('add') }}","link":"/2020/02/27/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"title":"JS基础知识（四）：异步","text":"同步和异步的区别单线程和异步 JS是单线程语言，只能同时做一件事 浏览器和nodejs以支持js启动进程，如Web Worker JS和DOM渲染共用同一个现成，因为JS可修改DOM结构 遇到等待（网络请求，定时任务）不能卡住 所以需要异步 异步基于callback函数形式 区别 异步基于JS是单线程语言 异步不会阻塞代码执行 同步会阻塞代码执行 应用场景 网络请求，如ajax图片加载 定时任务，如setTimeout 12345678// ajaxconsole.log('start')$.get('./data1.json', function (data1) { console.log(data1)})console.log('end')// 打印结果 1、start 2、end 3、data1 1234567891011// 图片加载console.log('start')let img = document.createElement('img')img.onload = function () { console.log('loaded')}img.src = '/xxx.png'console.log('end')// 打印结果 1、start 2、end 3、loaded 1234567// setTimeoutconsole.log(100)setTimeout(function () { console.log(200)}, 1000)console.log(300)// 打印结果 1、100 2、300 3、200 1234567// setIntervalconsole.log(100)setInterval(function () { console.log(200)}, 1000)console.log(300)// 打印结果 1、100 2、300 3、200 Promise Promise解决了“远古时期”回调地狱的问题 Callback hell（回调地狱）12345678910111213// 获取第一份数据$.get(url1 (data1) =&gt; { console.log(data1) // 获取第二份数据 $.get(url2, (data2) =&gt; { console.log(data2) // 获取第三份数据 $.get(url3, (data3) =&gt; { console.log(data3) ... }) })}) Promise123456789101112131415161718192021222324252627// 使用Promise封装异步请求function getData(url) { return new Promise((resolve, reject) =&gt; { $.ajax({ url, success(data) { resolve(data) }, error(err) { reject(err) } }) })}// 使用getData(url1).then(data1 =&gt; { console.log(data1) return getData(url2)}).then(data2 =&gt; { console.log(data2) return getData(url3)}).then(data3 =&gt; { console.log(data3)}).catch(err =&gt; { console.error(err)})","link":"/2020/03/06/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%BC%82%E6%AD%A5/"},{"title":"Koa+TypeScript从0到1实现简易CMS框架（一）：项目搭建以及配置","text":"目录 Koa+TypeScript从0到1实现简易CMS框架（一）：项目搭建以及配置 Koa+TypeScript从0到1实现简易CMS框架（二）：路由自动加载与全局异常处理 Koa+TypeScript从0到1实现简易CMS框架（三）：用户模型、参数校验与用户注册接口 项目地址：koa-typescript-cms 前言最近学习了慕课网七月老师的《从0到1手把手教你用Node.js+KOA2打造超好用的Web框架》，自己使用TypeScript重构了一个简单的cms框架，具有路由自动注册、全局异常处理、参数校验、JWT鉴权、权限管理等cms基础功能。 主要工具库 koa web框架 koa-bodyparser 处理koa post请求 koa-router koa路由 sequelize、sequelize-typescript、mysql2 ORM框架与Mysql validator、class-validator 参数校验 jsonwebtoken jwt bcryptjs 加密工具 reflect-metadata 给装饰器添加各种信息 nodemon 监听文件改变自动重启服务 lodash 非常好用的工具函数库 项目目录12345678910111213141516├── dist // ts编译后的文件├── src // 源码目录│ ├── components // 组件│ │ ├── app // 项目业务代码│ │ │ ├── api // api层│ │ │ ├── service // service层│ │ │ ├── model // model层│ │ │ ├── validators // 参数校验类│ │ │ ├── lib // interface与enum│ │ ├── core // 项目核心代码│ │ ├── middlewares // 中间件│ │ ├── config // 全局配置文件│ │ ├── app.ts // 项目入口文件├── tests // 单元测试├── package.json // package.json ├── tsconfig.json // ts配置文件 项目初始化初始化package.json创建项目文件夹，再控制台中打开此文件夹，输入npm init -y初始化package.json文件。 初始化TypeScript配置文件根目录运行tsc --init后，自动创建tsconfig.json文件，完成后，执行npm install typescript ts-node @types/node命令 tsconfig.json文件源码： 1234567891011121314151617181920{ \"compilerOptions\": { \"target\": \"ES2015\", /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019' or 'ESNEXT'. */ \"module\": \"commonjs\", /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */ \"declaration\": true, /* Generates corresponding '.d.ts' file. */ \"sourceMap\": true, /* Generates corresponding '.map' file. */ \"outDir\": \"./dist\", /* Redirect output structure to the directory. */ \"rootDir\": \"./src\", /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */ \"importHelpers\": true, /* Import emit helpers from 'tslib'. */ \"strict\": true, /* Enable all strict type-checking options. */ \"noImplicitAny\": false, /* Raise error on expressions and declarations with an implied 'any' type. */ \"typeRoots\": [\"./node_modules/@types\"], /* List of folders to include type definitions from. */ \"esModuleInterop\": true, /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */ \"experimentalDecorators\": true, /* Enables experimental support for ES7 decorators. */ \"emitDecoratorMetadata\": true, /* Enables experimental support for emitting type metadata for decorators. */ \"forceConsistentCasingInFileNames\": true /* Disallow inconsistently-cased references to the same file. */ }, \"exclude\": [\"node_modules\"], \"include\": [\"src\"]} 初始化koa服务执行npm install koa @types/koa命令在根目录创建src文件夹，并在文件夹下创建app.ts文件 app.ts文件代码： 123456import Koa from 'koa';const app = new Koa()app.listen(3000);console.log('Server running on port 3000'); 使用nodemon自动监听文件改变并重启服务执行npm install nodemon命令修改package.json文件中的scripts字段添加&quot;start&quot;: &quot;nodemon -e ts,tsx --exec ts-node ./src/app.ts&quot;添加此命令后，nodemon会监听src目录下文件改变，自动重启 修改后： 1234\"scripts\": { \"start\": \"nodemon -e ts,tsx --exec ts-node ./src/app.ts\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"} 创建配置文件再src目录创建config文件夹，并创建config.ts文件 定义各类Interfaceconfig interface123456export interface configInterface { environment?: string; // 环境变量 database: databaseInterface; // 数据库配置 security: securityInterface; // token生成配置 wx: wxInterface; // 微信小程序参数配置} security interface1234export interface securityInterface { secretKey?: string; // jwt的secretKey expiresIn?: number; // jwt的失效时间} datebase interface1234567export interface databaseInterface { dbName: string; // 数据库名称 host: string; // 数据库地址 port: number; // 数据库端口 user: string; // 数据库用户名 password?: string; // 数据库密码} wx interface12345export interface wxInterface { AppID?: string; // AppID AppSecret?: string; // AppSecret LoginUrl?: string // 小程序登录请求地址} 全部配置代码 12345678910111213141516171819export const config: configInterface = { environment: &quot;dev&quot;, database: { dbName: &quot;koacms&quot;, host: &quot;localhost&quot;, port: 3306, user: &quot;root&quot;, password: &quot;&quot; }, security: { secretKey: &quot;5465asd6as5d4as65d46sd&quot;, expiresIn: 60 * 60 * 24 * 30 }, wx: { AppID: &quot;你的AppID&quot;, AppSecret: &quot;你的AppSecret&quot;, LoginUrl: 'https://api.weixin.qq.com/sns/jscode2session?appid=%s&amp;secret=%s&amp;js_code=%s&amp;grant_type=authorization_code' }}; 下一篇：Koa+TypeScript从0到1实现简易CMS框架（二）：路由自动加载与全局异常处理","link":"/2020/02/28/Koa-TypeScript%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93CMS%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"title":"Koa+TypeScript从0到1实现简易CMS框架（三）：用户模型、参数校验与用户注册接口","text":"目录 Koa+TypeScript从0到1实现简易CMS框架（一）：项目搭建以及配置 Koa+TypeScript从0到1实现简易CMS框架（二）：路由自动加载与全局异常处理 Koa+TypeScript从0到1实现简易CMS框架（三）：用户模型、参数校验与用户注册接口 项目地址：koa-typescript-cms 前言用户系统是一个cms最重要的部分，也是最复杂的部分，需要进行很多安全处理。每次用户请求接口时，我们要进行参数校验，以防用户传入危险以及不规范数据 主要工具库 koa web框架 koa-bodyparser 处理koa post请求 koa-router koa路由 sequelize、sequelize-typescript、mysql2 ORM框架与Mysql validator、class-validator 参数校验 jsonwebtoken jwt bcryptjs 加密工具 reflect-metadata 给装饰器添加各种信息 nodemon 监听文件改变自动重启服务 lodash 非常好用的工具函数库 项目目录12345678910111213141516├── dist // ts编译后的文件├── src // 源码目录│ ├── components // 组件│ │ ├── app // 项目业务代码│ │ │ ├── api // api层│ │ │ ├── service // service层│ │ │ ├── model // model层│ │ │ ├── validators // 参数校验类│ │ │ ├── lib // interface与enum│ │ ├── core // 项目核心代码│ │ ├── middlewares // 中间件│ │ ├── config // 全局配置文件│ │ ├── app.ts // 项目入口文件├── tests // 单元测试├── package.json // package.json ├── tsconfig.json // ts配置文件 初始化Sequelize配置再src/core目录下创建db.ts文件，引入sequelize-typescript与config.ts配置文件。 12import { Sequelize, Model } from \"sequelize-typescript\";import { config, databaseInterface } from \"../config/config\"; 初始化数据库信息123456789101112131415161718192021// 数据库配置信息const { dbName, user, password, host, port }: databaseInterface = config.database;// 初始化Sequelizeconst sequelize: Sequelize = new Sequelize( dbName, // 数据库名称 user, // 数据库用户名 password, // 数据库密码 { dialect: \"mysql\", // 数据库引擎 host, // 数据库地址 port, // 数据库端口 logging: true, // 是否打印日志 timezone: \"+08:00\", // 设置数据库市区，建议设置，mysql默认的时区比东八区少了八个小时 define: { timestamps: true, // 为模型添加 createdAt 和 updatedAt 两个时间戳字段 paranoid: true, // 使用逻辑删除。设置为true后，调用 destroy 方法时将不会删队模型，而是设置一个 deletedAt 列。此设置需要 timestamps=true underscored: true, // 转换列名的驼峰命名规则为下划线命令规则 freezeTableName: true // 转换模型名的驼峰命名规则为表名的下划线命令规则 } }); 设置sequelize是否自动建表1234sequelize.sync({ // 是否自动建表 force: false}); JSON序列化JSON序列化是使sequelize每次返回都默认排除我们不想要的字段。 sequelize的Model的原型上会有一个toJSON方法，这个是Model默认的序列化方法，我们要重写它这个方法： 1234567891011121314151617Model.prototype.toJSON = function(): object { // 浅拷贝从数据库获取到的数据 let data = clone(this['dataValues']) // 删除指定字段 unset(data, 'updatedAt') unset(data, 'deletedAt') // 这个是自己再Model原型上定义的变量 // 用于控制我们再某次查询数据时想要排除的其他字段 // 类型为数组，数组的值便是想要排除的字段 // 例如user.exclude['a', 'b']，此次查询将会增加排除a,b字段 if(isArray(this['exclude'])) { this['exclude'].forEach(value =&gt; { unset(data, value) }) } return data;}; 全部代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import { Sequelize, Model } from \"sequelize-typescript\";import { config, databaseInterface } from \"../config/config\";import { unset,clone, isArray } from \"lodash\";// 数据库配置信息const { dbName, user, password, host, port}: databaseInterface = config.database;// 初始化Sequelizeconst sequelize: Sequelize = new Sequelize( dbName, // 数据库名称 user, // 数据库用户名 password, // 数据库密码 { dialect: \"mysql\", // 数据库引擎 host, // 数据库地址 port, // 数据库端口 logging: true, // 是否打印日志 timezone: \"+08:00\", // 设置数据库市区，建议设置，mysql默认的时区比东八区少了八个小时 define: { timestamps: true, // 为模型添加 createdAt 和 updatedAt 两个时间戳字段 paranoid: true, // 使用逻辑删除。设置为true后，调用 destroy 方法时将不会删队模型，而是设置一个 deletedAt 列。此设置需要 timestamps=true underscored: true, // 转换列名的驼峰命名规则为下划线命令规则 freezeTableName: true // 转换模型名的驼峰命名规则为表名的下划线命令规则 } });sequelize.sync({ // 是否自动建表 force: false});Model.prototype.toJSON = function(): object { // 浅拷贝从数据库获取到的数据 let data = clone(this['dataValues']) // 删除指定字段 unset(data, 'updatedAt') unset(data, 'deletedAt') // 这个是自己再Model原型上定义的变量 // 用于控制我们再某次查询数据时想要排除的其他字段 // 类型为数组，数组的值便是想要排除的字段 // 例如user.exclude['a', 'b']，此次查询将会增加排除a,b字段 if(isArray(this['exclude'])) { this['exclude'].forEach(value =&gt; { unset(data, value) }) } return data;};export { sequelize }; 创建Users模型sequelize-typescript创建模型和sequelize创建模型区别还是挺大的，sequelize-typescript中大部分字段的配置都是基于装饰器来实现。下面直接贴上代码，基本看一遍就知道怎么回事了。 注意事项： 千万不要忘记@Table装饰器，少写这个装饰器会报错 也不要忘记向Model里传入泛型 12345678910111213141516171819202122232425262728293031323334353637383940414243import { sequelize } from \"../../core/db\";import { Model, Table, Column, DataType, PrimaryKey, AutoIncrement, Unique, Comment,} from \"sequelize-typescript\";// 千万不要忘记Table装饰器，少写这个装饰器会报错// 也不要忘记向Model里传入泛型@Tableclass Users extends Model&lt;Users&gt; { @PrimaryKey @AutoIncrement @Comment(\"ID\") @Column(DataType.INTEGER) id?: number; @Comment(\"用户昵称\") @Column(DataType.STRING(128)) nickname?: string; @Unique @Comment(\"用户邮箱\") @Column(DataType.STRING(128)) email?: string; @Comment(\"用户密码\") @Column(DataType.STRING(64)) password?: string; @Unique @Comment(\"微信小程序openid\") @Column(DataType.STRING(128)) openid?: string;}sequelize.addModels([Users]);export default Users; 参数校验 参数校验是一个系统中必不可少的部分，尤其是前后端分离的架构模式，为了更方便的使用参数校验，我们需要自己封装一个类，实现代码更高的复用性，此类模仿lin-cms-koa的参数校验的基本功能进行封装。 Validator封装在src/core文件夹下创建validator.ts文件，引入需要的依赖： 1234import { validateOrReject } from \"class-validator\";import { Context } from \"koa\";import { cloneDeep } from \"lodash\";import { ParametersException } from \"./exception\"; Validator类封装思路： 解析koa的Context，获取到可能接收到用户传来的参数的字段，进行拍平（扁平化） 遍历所有参数，将它们的key挂载到原型上。 使用class-validator进行参数校验。 实现代码: 123456789101112131415161718192021222324252627export class Validator { async validate(ctx: Context) { const params = { ...ctx.request.body, ...ctx.request.query, ...ctx.params }; const data = cloneDeep(params); for (let key in params) { this[key] = params[key]; } try { await validateOrReject(this); return data; } catch (errors) { let errorResult: string[] = []; errors.forEach(error =&gt; { let messages: string[] = []; for (let msg in error.constraints) { messages.push(error.constraints[msg]); } errorResult = errorResult.concat(messages) }); throw new ParametersException({ msg: errorResult }); } }} 具体使用方式在用户注册接口时进行演示 用户注册接口创建/v1/user/register路由在src/app/api/v1目录下创建users.ts文件，由于我们之前写了路由自动注册功能，所以我们只需要将路由导出即可，不需要再app.ts中引入路由。 引入koa-router 12import Router from \"koa-router\";const router: Router = new Router(); 设置路由的prefix 1router.prefix(\"/v1/user\"); 创建路由： 1router.post(\"/register\", async ctx =&gt; {}); 参数校验上文我们已经将Validator类封装好了，在src/app/validators目录下创建UsersValidator.ts文件，参数校验是基于class-validator，具体使用方式可以观看官网文档，直接上基础代码： 12345678910111213141516171819202122232425/** * 注册验证类 * * @export * @class RegistorValidator * @extends {Validator} */export class RegistorValidator extends Validator { constructor() { super(); } @Length(3, 10, { message: \"用户名长度为3~10个字符\" }) nickname?: string; @IsEmail({},{ message: \"电子邮箱格式错误\" }) email?: string; @Validate(CheckPassword) // 至少8-16个字符，至少1个大写字母，1个小写字母和1个数字，其他可以是任意字符： @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[^]{8,16}$/, { message: \"密码至少8-16个字符，至少1个大写字母，1个小写字母和1个数字\" }) password1?: string; password2?: string;} 由于我们需要判断password1和password2是否相等，class-validator没有相似功能，我们自己创建一个校验方法： 12345678910111213141516/** * 验证密码自定义装饰器 * * @class CheckPassword * @implements {ValidatorConstraintInterface} */@ValidatorConstraint()class CheckPassword implements ValidatorConstraintInterface { validate(text: string, args: ValidationArguments): boolean { const obj: any = args.object; return obj.password1 === obj.password2; } defaultMessage() { return \"两次输入密码不一致\"; }} 在password1属性上可以直接使用装饰器挂载这个自定义方法： 12@Validate(CheckPassword)password1?: string; 至此注册接口的校验器完成，全部代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import { Length, IsEmail, Matches, Validate, ValidatorConstraintInterface, ValidatorConstraint, ValidationArguments} from \"class-validator\";import { Validator } from \"../../core/validator\";/** * 验证密码自定义装饰器 * * @class CheckPassword * @implements {ValidatorConstraintInterface} */@ValidatorConstraint()class CheckPassword implements ValidatorConstraintInterface { validate(text: string, args: ValidationArguments): boolean { const obj: any = args.object; return obj.password1 === obj.password2; } defaultMessage() { return \"两次输入密码不一致\"; }}/** * 注册验证类 * * @export * @class RegistorValidator * @extends {Validator} */export class RegistorValidator extends Validator { constructor() { super(); } @Length(3, 10, { message: \"用户名长度为3~10个字符\" }) nickname?: string; @IsEmail({},{ message: \"电子邮箱格式错误\" }) email?: string; @Validate(CheckPassword) // 至少8-16个字符，至少1个大写字母，1个小写字母和1个数字，其他可以是任意字符： @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[^]{8,16}$/, { message: \"密码至少8-16个字符，至少1个大写字母，1个小写字母和1个数字\" }) password1?: string; password2?: string;} 在路由文件中使用校验器，调用校验器类上的validate方法，将koa的Context传入。如果校验成功则将请求参数封装成一个对象并返回，如果失败则直接利用全局异常处理中间件 向客户抛出错误信息： 123router.post(\"/register\", async ctx =&gt; { const v: registerInterface = await new RegistorValidator().validate(ctx);}); registerInterface接口存放了注册所需要的参数，代码： 123456export interface registerInterface { email: string; nickname: string; password1: string; password2: string;} 实现注册功能在src/app/service目录下创建users.ts文件，此目录专门存放进行数据库业务操作的文件。 在users.ts中创建UsersService类，在类中创建静态方法userRegister，此方法进行注册操作。 注册步骤： 判断数据库中是否存在此用户 如果存在则向用户抛出异常 如果不存在则将数据插入数据库 业务代码： 123456789101112131415161718static async userRegister(params: registerInterface) { const { email, nickname, password1 } = params; const data = { email, nickname, password: password1 }; const isExistEmail = await Users.findOne({ where: { email } }); if (isExistEmail) { throw new Failed({ msg: \"Email已存在\" }); } const r = await Users.create(data); return r;} 全部代码： 123456789101112131415161718192021222324import Users from \"../models/users\";import { Failed } from \"../../core/exception\";import { registerInterface } from \"../lib/interface/UsersInterface\";class UsersService { static async userRegister(params: registerInterface) { const { email, nickname, password1 } = params; const data = { email, nickname, password: password1 }; const isExistEmail = await Users.findOne({ where: { email } }); if (isExistEmail) { throw new Failed({ msg: \"Email已存在\" }); } const r = await Users.create(data); return r; }}export default UsersService; 在路由中引入注册功能代码： 123456789router.post(\"/register\", async ctx =&gt; { const v: registerInterface = await new RegistorValidator().validate(ctx); const r = await UsersService.userRegister(v); if (r) { throw new Success(); } else { throw new Failed({msg: '注册失败'}); }}); 路由文件全部代码：1234567891011121314151617181920import Router from \"koa-router\";import { RegistorValidator } from \"../../validators/UsersValidator\";import { Success, Failed } from \"../../../core/exception\";import { registerInterface } from '../../lib/interface/UsersInterface';import UsersService from '../../service/users';const router: Router = new Router();router.prefix(\"/v1/user\");router.post(\"/register\", async ctx =&gt; { const v: registerInterface = await new RegistorValidator().validate(ctx); const r = await UsersService.userRegister(v); if (r) { throw new Success(); } else { throw new Failed({msg: '注册失败'}); }});// 这里一定要用commonjs规范导出module.exports = router; 更新中……","link":"/2020/02/28/Koa-TypeScript%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93CMS%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9E%8B%E3%80%81%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E4%B8%8E%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E6%8E%A5%E5%8F%A3/"},{"title":"Koa+TypeScript从0到1实现简易CMS框架（二）：路由自动加载与全局异常处理","text":"目录 Koa+TypeScript从0到1实现简易CMS框架（一）：项目搭建以及配置 Koa+TypeScript从0到1实现简易CMS框架（二）：路由自动加载与全局异常处理 Koa+TypeScript从0到1实现简易CMS框架（三）：用户模型、参数校验与用户注册接口 项目地址：koa-typescript-cms 前言koa本身是没有路由的，需借助第三方库koa-router实现路由功能，但是路由的拆分，导致app.ts里需要引入许多路由文件，为了方便，我们可以做一个简单的路由自动加载功能来简化我们的代码量；全局异常处理是每个cms框架中比不可少的部分，我们可以通过koa的中间件机制来实现此功能。 主要工具库 koa web框架 koa-bodyparser 处理koa post请求 koa-router koa路由 sequelize、sequelize-typescript、mysql2 ORM框架与Mysql validator、class-validator 参数校验 jsonwebtoken jwt bcryptjs 加密工具 reflect-metadata 给装饰器添加各种信息 nodemon 监听文件改变自动重启服务 lodash 非常好用的工具函数库 项目目录12345678910111213141516├── dist // ts编译后的文件├── src // 源码目录│ ├── components // 组件│ │ ├── app // 项目业务代码│ │ │ ├── api // api层│ │ │ ├── service // service层│ │ │ ├── model // model层│ │ │ ├── validators // 参数校验类│ │ │ ├── lib // interface与enum│ │ ├── core // 项目核心代码│ │ ├── middlewares // 中间件│ │ ├── config // 全局配置文件│ │ ├── app.ts // 项目入口文件├── tests // 单元测试├── package.json // package.json ├── tsconfig.json // ts配置文件 路由自动加载思路:（此功能借鉴lin-cms开源的lin-cms-koa-core） 获取api文件夹下的所有文件 判断文件的后缀名是否为.ts，如果是，使用CommonJS规范加载文件 判断文件导出的内容是否为Router类型，如果是，则加载路由 由于我们需要很多功能到要在服务执行后就加载，所以创建一个专门加载功能的类InitManager。再InitManager类中创建类方法initLoadRouters，此方法专门作为加载路由的功能模块。先创建一个辅助函数getFiles，此函数利用node的fs文件功能模块，来获取某文件夹下后的所有文件名，并返回一个字符串数组： 123456789101112131415161718192021/** * 获取文件夹下所有文件名 * * @export * @param {string} dir * @returns */export function getFiles(dir: string): string[] { let res: string[] = []; const files = fs.readdirSync(dir); for (const file of files) { const name = dir + \"/\" + file; if (fs.statSync(name).isDirectory()) { const tmp = getFiles(name); res = res.concat(tmp); } else { res.push(name); } } return res;} 接下来编写路由自动加载功能： 12345678910111213141516171819202122232425262728293031/** * 路由自动加载 * * @static * @memberof InitManager */static initLoadRouters() { const mainRouter = new Router(); const path: string = `${process.cwd()}/src/app/api`; const files: string[] = getFiles(path); for (let file of files) { // 获取文件后缀名 const extention: string = file.substring( file.lastIndexOf(\".\"), file.length ); if (extention === \".ts\") { // 加载api文件夹下所有文件 // 并检测文件是否是koa的路由 // 如果是路由便将路由加载 const mod: Router = require(file); if (mod instanceof Router) { // consola.info(`loading a router instance from file: ${file}`); get(mod, \"stack\", []).forEach((ly: Router.Layer) =&gt; { consola.info(`loading a route: ${get(ly, \"path\")}`); }); mainRouter.use(mod.routes()).use(mod.allowedMethods()); } } }} 在InitManager中创建另一个类方法initCore，此方法需传入一个koa实例，统一加载InitManager类中的其他功能模块。 1234567891011/** * 入口方法 * * @static * @param {Koa} app * @memberof InitManager */static initCore(app: Koa) { InitManager.app = app; InitManager.initLoadRouters();} 需要注意的是，路由文件导出的时候不能再以ES的规范导出了，必须以CommonJS的规范进行导出。 例api/v1/book.ts文件源码： 12345678910import Router from 'koa-router'const router: Router = new Router();router.prefix('/v1/book')router.get('/', async (ctx) =&gt; { ctx.body = 'Hello Book';});// 注意这里module.exports = router 最后在app.ts中加载，代码： 123import InitManager from './core/init'InitManager.initCore(app) 此为还需要全局加载配置文件，与加载路由大同小异，代码一并附上 app/core/init.ts全部代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import Koa from \"koa\";import Router from \"koa-router\";import consola from \"consola\";import { get } from \"lodash\";[import { getFiles } from \"./utils\";import { config, configInterface } from \"../config/config\";declare global { namespace NodeJS { interface Global { config?: configInterface; } }}class InitManager { static app: Koa&lt;Koa.DefaultState, Koa.DefaultContext&gt;; /** * 入口方法 * * @static * @param {Koa} app * @memberof InitManager */ static initCore(app: Koa) { InitManager.app = app; InitManager.initLoadRouters(); InitManager.loadConfig(); } /** * 路由自动加载 * * @static * @memberof InitManager */ static initLoadRouters() { const mainRouter = new Router(); const path: string = `${process.cwd()}/src/app/api`; const files: string[] = getFiles(path); for (let file of files) { // 获取文件后缀名 const extention: string = file.substring( file.lastIndexOf(\".\"), file.length ); if (extention === \".ts\") { // 加载api文件夹下所有文件 // 并检测文件是否是koa的路由 // 如果是路由便将路由加载 const mod: Router = require(file); if (mod instanceof Router) { // consola.info(`loading](https://note.youdao.com/) a router instance from file: ${file}`); get(mod, \"stack\", []).forEach((ly: Router.Layer) =&gt; { consola.info(`loading a route: ${get(ly, \"path\")}`); }); mainRouter.use(mod.routes()).use(mod.allowedMethods()); } } } } /** * 载入配置文件 * * @static * @memberof InitManager */ static loadConfig() { global.config = config; }}export default InitManager; 全局异常处理此功能需依赖koa的中间件机制进行开发异常分为已知异常与未知异常，需针对其进行不同处理 常见的已知异常：路由参数错误、从数据库查询查询到空数据……常见的未知错误：不正确的代码导致的依赖库报错…… 已知异常我们需要向用户抛出，以json的格式返回到客户端。而未知异常一般只有在开发环境才会让它抛出，并且只有开发人员可以看到。 已知异常向用户抛出时，需携带错误信息、错误代码、请求路径等信息。我们需要针对已知异常封装一个类，用来标识错误为已知异常。在app/core目录下创建文件exception.ts，此文件里有一个基类HttpException，此类继承JavaScript的内置对象Error，之后所有的已知异常类都将继承HttpException。代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * HttpException 类构造函数的参数接口 */export interface Exception { code?: number; msg?: any; errorCode?: number;}export class HttpException extends Error { /** * http 状态码 */ public code: number = 500; /** * 返回的信息内容 */ public msg: any = \"服务器未知错误\"; /** * 特定的错误码 */ public errorCode: number = 999; public fields: string[] = [\"msg\", \"errorCode\"]; /** * 构造函数 * @param ex 可选参数，通过{}的形式传入 */ constructor(ex?: Exception) { super(); if (ex &amp;&amp; ex.code) { assert(isInteger(ex.code)); this.code = ex.code; } if (ex &amp;&amp; ex.msg) { this.msg = ex.msg; } if (ex &amp;&amp; ex.errorCode) { assert(isInteger(ex.errorCode)); this.errorCode = ex.errorCode; } }} 针对以上的情况进行编码app/middlewares/exception.ts全部代码： 123456789101112131415161718192021222324252627282930313233343536import { BaseContext, Next } from \"koa\";import { HttpException, Exception } from \"../core/exception\";interface CatchError extends Exception { request?: string;}const catchError = async (ctx: BaseContext, next: Next) =&gt; { try { await next(); } catch (error) { const isHttpException = error instanceof HttpException const isDev = global.config?.environment === \"dev\" if (isDev &amp;&amp; !isHttpException) { throw error; } if (isHttpException) { const errorObj: CatchError = { msg: error.msg, errorCode: error.errorCode, request: `${ctx.method} ${ctx.path}` }; ctx.body = errorObj; ctx.status = error.code; } else { const errorOjb: CatchError = { msg: \"出现异常\", errorCode: 999, request: `${ctx.method} ${ctx.path}` }; ctx.body = errorOjb; ctx.status = 500; } }};export default catchError; 最后，app.ts里使用中间件，app.ts代码： 1234567891011import Koa from 'koa';import InitManager from './core/init'import catchError from './middlewares/exception';const app = new Koa()app.use(catchError)InitManager.initCore(app)app.listen(3001);console.log('Server running on port 3001'); 下一篇：Koa+TypeScript从0到1实现简易CMS框架（三）：用户模型、参数校验与用户注册接口","link":"/2020/02/28/Koa-TypeScript%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93CMS%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%B7%AF%E7%94%B1%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"title":"Vue2.x源码分析（一）：new Vue发生了什么","text":"Vue源码分析 + 逐行注释 Github地址 new Vue()做了什么？首先，Vue会判断当前的this是否是Vue实例，如果是则会调用this._init()初始化Vue配置，如果不是则抛出警告 代码src/core/instance/index.js： 12345678function Vue(options) { if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) { warn('Vue is a constructor and should be called with the `new` keyword') } this._init(options)} Vue都初始化了什么？在初始化Vue时，Vue会执行一些混入操作，将一些方法等挂载到Vue的原型链上，混入完成后，将Vue类（其实定义一个function则是定义一个类，只不过Vue没有使用ES6的class语法糖，而是用原型链的方式）导出 代码src/core/instance/index.js： 123456789101112131415import { initMixin } from './init'import { stateMixin } from './state'import { renderMixin } from './render'import { eventsMixin } from './events'import { lifecycleMixin } from './lifecycle'function Vue(options) { ....}initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue this._init()从何而来this._init()是由混入方法initMixin挂载到原型链上的一个方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758export function initMixin (Vue: Class&lt;Component&gt;) { Vue.prototype._init = function (options?: Object) { const vm: Component = this // a uid vm._uid = uid++ let startTag, endTag /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { startTag = `vue-perf-start:${vm._uid}` endTag = `vue-perf-end:${vm._uid}` mark(startTag) } // a flag to avoid this being observed vm._isVue = true // merge options if (options &amp;&amp; options._isComponent) { // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) } else { vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm ) } /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') { initProxy(vm) } else { vm._renderProxy = vm } // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue ${vm._name} init`, startTag, endTag) } if (vm.$options.el) { vm.$mount(vm.$options.el) } }} 总结Vue初始化主要做了合并配置、初始化生命周期、初始化事件中心、初始化渲染、初始化data、props、computed、watcher等。初始化完成后判断$option里有没用传入el（字符串），如果有，则使用原型上的$mount挂载DOM。","link":"/2020/03/31/Vue2.x%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AnewVue%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"},{"title":"Vue2.x源码分析（二）：Vue实例挂载的实现","text":"Vue源码分析 + 逐行注释 Github地址 在Vue实例挂载阶段，这里只分析web平台的实现，web平台的入口文件是src/platforms/web/entry-runtime-with-compiler.js，在此文件中Vue通过$mount方法进行实例挂载。 Vue挂载阶段都做了什么？在src/platforms/web/entry-runtime-with-compiler.js文件$mount方法定义之前，$mount已经在runtime(src/platforms/web/runtime/index.js文件)里定义了一遍，在该文件里刚开始就对·$mount做一个缓存，缓存为mount变量，方便之后使用。 entry-runtime-with-compiler.js文件做了什么？entry-runtime-with-compiler.js文件中的$mount方法在Vue init时被调用，此方法接收两个参数，第一个参数el是DOM元素，可以是string或Element，第二个参数hydrating是关于Vue服务端渲染的，可以忽略。 首先，将传入的el参数通过query方法转换DOM对象，接着判断el是否为body或者documentElement，如果是则报出错误（不允许为&lt;html&gt; 或者&lt;body&gt;） 并直接return当前实例，不再往下执行。 接下来，对实例上的$options进行一个缓存，缓存变量为options，因为Vue支持直接传入render函数，所以会进行判断如果不存在render函数，则判断是否有template，再把template转换成一个render函数，最终目的是调用缓存的mount方法进行DOM挂载。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// $mount已经在runtime里定义了一遍，在这里对$mount做一个缓存const mount = Vue.prototype.$mount// 重新定义$mount// 此$mount在init时被调用// 最终目的是调用mount方法进行DOM挂载Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component { // 通过query方法转换DOM对象 el = el &amp;&amp; query(el) /* istanbul ignore if */ // 判断是否为body或者documentElement，如果是则报出错误（不允许为&lt;html&gt; 或者 &lt;body&gt;） // document.body：https://developer.mozilla.org/zh-CN/docs/Web/API/Document/body // document.documentElement：https://developer.mozilla.org/zh-CN/docs/Web/API/Document/documentElement if (el === document.body || el === document.documentElement) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this } // options缓存 const options = this.$options // resolve template/el and convert to render function // Vue支持传入render函数 // 如果不存在render函数，则判断是否有template，再把template转换成一个render函数 // 所有template最终都会被转换成render if (!options.render) { // 缓存template let template = options.template // 如果存在template if (template) { if (typeof template === 'string') { if (template.charAt(0) === '#') { // 如果template是一个字符串,并且第一个字符为'#' // 则此时的template是一个DOM的ID名 // 通过idToTemplate方法转换成真实DOM template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; !template) { warn( `Template element not found or is empty: ${options.template}`, this ) }r } } else if (template.nodeType) { // 如果template是一个Node节点 // 则将template赋值为template.innerHTML(DOM字符串) // nodeType：https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType // innerHTML：https://developer.mozilla.org/zh-CN/docs/Web/API/Element/innerHTML template = template.innerHTML } else { // 如果以上都不是,则报错 if (process.env.NODE_ENV !== 'production') { warn('invalid template option:' + template, this) } return this } } else if (el) { // 如果el存在,则调用getOuterHTML获取outerHTML template = getOuterHTML(el) } if (template) { /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { mark('compile') } // 通过compileToFunctions获取到render const { render, staticRenderFns } = compileToFunctions(template, { outputSourceRange: process.env.NODE_ENV !== 'production', shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments }, this) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { mark('compile end') measure(`vue ${this._name} compile`, 'compile', 'compile end') } } } return mount.call(this, el, hydrating)}/** * Get outerHTML of elements, taking care * of SVG elements in IE as well. * 获取outerHTML * outerHTML:https://developer.mozilla.org/zh-CN/docs/Web/API/Element/outerHTML * appendChild:https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild * cloneNode:https://developer.mozilla.org/zh-CN/docs/Web/API/Node/cloneNode * polyfill:https://developer.mozilla.org/zh-CN/docs/Glossary/Polyfill */function getOuterHTML (el: Element): string { // 如果outerHTML存在，则直接return if (el.outerHTML) { return el.outerHTML } else { // 如果不存在，则创建一个空的div，将el深度克隆到新的div的尾部 // 做一个outerHTML的polyfill const container = document.createElement('div') container.appendChild(el.cloneNode(true)) // 返回当前innerHTML return container.innerHTML }} runtime/index.js $mount文件做了什么？runtime里的$mount同样接收两个参数，与entry-runtime-with-compiler.js文件中无差。 runtime $mount方法首先会将传入来的el参数通过query方法转换DOM对象（如果是浏览器环境），然后调用mountComponent方法生成虚拟DOM，并将生成的虚拟DOMreturn出去。 12345678910// public mount methodVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component { // 通过query方法转换DOM对象 el = el &amp;&amp; inBrowser ? query(el) : undefined // 调用mountComponent生成虚拟DOM return mountComponent(this, el, hydrating)} mountComponent方法做了什么？mountComponent方法定义在src/core/instance/lifecycle.js下，此方法第一个第一个参数vm需传入一个Vue实例，第二个与第三个参数与$mount方法的参数意义一样。 mountComponent方法首先会将传入的el缓存挂载到Vue的实例上，名为$el，紧接着判断render函数是否存在，如果存在则会创建一个空的VNode，然后判断是否为production环境，因为在production环境中，runtime-only版本如果当前配置了template且template传入的不是一个id名称或者存在el属性，则报错，此时的情况只能使用render函数进行DOM挂载。 判断完是否存在render函数后，则会调用beforeMount生命周期钩子，此时DOM正在挂载中。下一步则创建一个updateComponent方法，该方法调用render方法生成虚拟node，然后实例化一个渲染Watcher，通过Watcher监听数据改变，当数据改变时，调用第二个参数触发_update进行更新DOM。 所有任务进行完成后，将当前实例重新return出去。 mountComponent方法主要作用就是渲染DOM，然后监听数据改变，进行DOM更新。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component { // 缓存$el vm.$el = el // 如果当前没有render函数 if (!vm.$options.render) { // 创建一个空的VNode vm.$options.render = createEmptyVNode if (process.env.NODE_ENV !== 'production') { /* istanbul ignore if */ // 在runtime-only版本如果当前配置了template且template传入的不是一个ID名称 // 或者存在el属性 // 则报错 // 此时只能使用render函数 if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== '#') || vm.$options.el || el) { warn( 'You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm ) } else { // 如果什么都没有传入,则报错 warn( 'Failed to mount component: template or render function not defined.', vm ) } } } // 调用beforeMount生命周期钩子 callHook(vm, 'beforeMount') let updateComponent /* istanbul ignore if 性能统计相关 */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { updateComponent = () =&gt; { const name = vm._name const id = vm._uid const startTag = `vue-perf-start:${id}` const endTag = `vue-perf-end:${id}` mark(startTag) const vnode = vm._render() mark(endTag) measure(`vue ${name} render`, startTag, endTag) mark(startTag) vm._update(vnode, hydrating) mark(endTag) measure(`vue ${name} patch`, startTag, endTag) } } else { updateComponent = () =&gt; { // 调用render方法生成虚拟node vm._update(vm._render(), hydrating) } } // we set this to vm._watcher inside the watcher's constructor // since the watcher's initial patch may call $forceUpdate (e.g. inside child // component's mounted hook), which relies on vm._watcher being already defined // 实例化一个渲染watcher // 当数据改变时，调用第二个参数触发_update进行更新DOM new Watcher(vm, updateComponent, noop, { before () { if (vm._isMounted &amp;&amp; !vm._isDestroyed) { callHook(vm, 'beforeUpdate') } } }, true /* isRenderWatcher */) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) { vm._isMounted = true callHook(vm, 'mounted') } return vm}","link":"/2020/04/07/Vue2.x%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AVue%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"Vue侦听器watch获取this报undefined","text":"错误代码12345678watch: { data: { handler: (newVal) =&gt; { this.info = newVal }, deep: true }}, 修正后代码12345678watch: { data: { handler: function (newVal) { this.info = newVal }, deep: true }}, 原因 总的来说还是 this 指向问题，可以查看普通函数与箭头函数 this 指向问题","link":"/2020/01/14/Vue%E4%BE%A6%E5%90%AC%E5%99%A8watch%E8%8E%B7%E5%8F%96this%E6%8A%A5undefined/"},{"title":"mr-progress-vue文档","text":"简单demo查看文件dome/index.html，只有两个最基础demo 详细演示查看按步骤执行 npm install or yarn install npm run serve or yarn serve 使用方式可使用npm install mr-progress-vue --save进行安装 同时可引入lib文件夹下progress.umd.min.js进行使用 本项目依赖于Vue2.x，请自行安装 1234567// main.js Vue入口文件引入import mrProgress from 'mr-progress-vue'import 'mr-progress-vue/lib/mr-progress.css'Vue.component(mrProgress.name, mrProgress)// 组件内使用&lt;mrProgress :percentage=\"20\" /&gt; 12345678910// 组件内引入import mrProgress from 'mr-progress-vue'import 'mr-progress-vue/lib/mr-progress.css'export default { components: { mrProgress, }}// 组件内使用&lt;mrProgress :percentage=\"20\" /&gt; mr-progress文档 以下具体演示请运行项目查看 进度条定制type属性等于line为线性进度条，等于circle为环形进度提 线性进度条1&lt;mr-Progress :percentage=\"20\" type=\"line\"/&gt; 环形进度条1&lt;mr-Progress :percentage=\"20\" type=\"circle\" /&gt; 进度条内容定制进度条内容支持插槽插入，插槽支持任意内容。 线性进度条可百分比内显，需将textInside属性设置为true 插槽内容12345678// 线性进度条&lt;mr-progress :percentage=\"percentage\"&gt; &lt;span class=\"percentage\"&gt;{{ percentage }}%&lt;/span&gt;&lt;/mr-progress&gt;// 环形进度条&lt;mr-progress :percentage=\"percentage\" type=\"circle\"&gt; &lt;span class=\"percentage\"&gt;{{ percentage }}%&lt;/span&gt;&lt;/mr-progress&gt; 线性进度条百分比内显1&lt;mr-Progress :percentage=\"percentage\" textInside&gt; &lt;/mr-Progress&gt; 进度条颜色定制设置strokeColor属性可更改进度条颜色，支持输入字符串与数组 当strokeColor为数组时，格式为： [ ​ { color: 颜色, percentage: 进度 }, ​ { color: 颜色, percentage: 进度 }, ​ …. ] 详细查看演示项目 设置strokeBgColor属性可更改进度条背景颜色，只支持输入字符串 123456&lt;mr-progress :strokeColor=\"color\" :percentage=\"percentage\" /&gt;&lt;mr-progress :strokeColor=\"color\" :percentage=\"percentage\" type=\"circle\" /&gt;&lt;mr-progress :strokeBgColor=\"color\" :percentage=\"percentage\" /&gt;&lt;mr-progress :strokeBgColor=\"color\" :percentage=\"percentage\" type=\"circle\" /&gt;&lt;mr-progress :strokeColor=\"colorArr\" :percentage=\"percentage\" /&gt;&lt;mr-progress :strokeColor=\"colorArr\" :percentage=\"percentage\" type=\"circle\" /&gt; 进度条宽度定制设置width属性可更改进度条宽度，单位px 12&lt;mr-progress :width=\"200\" :percentage=\"percentage\" /&gt;&lt;mr-progress :width=\"200\" :percentage=\"percentage\" type=\"circle\" /&gt; 进度条进度线宽度定制设置strokeWidth属性可更改进度线宽度，单位为px 12&lt;mr-progress :strokeWidth=\"25\" :percentage=\"percentage\" /&gt;&lt;mr-progress :strokeWidth=\"25\" :percentage=\"percentage\" type=\"circle\" /&gt; 进度条样式定制设置strokeLinecap属性可更改进度条样式，该值可选round或butt round：椭圆形样式 butt：长方形样式 1234&lt;mr-progress :strokeWidth=\"25\" :percentage=\"percentage\" strokeLinecap=\"round\" /&gt;&lt;mr-progress :strokeWidth=\"25\" :percentage=\"percentage\" strokeLinecap=\"butt\" /&gt;&lt;mr-progress :strokeWidth=\"25\" :percentage=\"percentage\" type=\"circle\" strokeLinecap=\"round\" /&gt;&lt;mr-progress :strokeWidth=\"25\" :percentage=\"percentage\" type=\"circle\" strokeLinecap=\"butt\" /&gt; mr-progress属性 参数 说明 类型 可选值 默认值 type 进度条类型 String circle/line line width 容器宽度，单位px Number — 300 strokeWidth 进度条宽度，单位px Number — 20 strokeColor 进度条颜色 String/ Array — #6f7ad3 strokeBgColor 背景进度条颜色 String — #e5e9f2 percentage 进度 Number 0~100 0 strokeLinecap 进度条样式 String round/butt round textInside 线性进度条百分比内显 Boolean — false","link":"/2020/04/05/mr-progress-vue%E6%96%87%E6%A1%A3/"},{"title":"vue-awesome-swiper报错踩坑记","text":"nuxt.js 引入 vue-awesome-swiper 后，控制台报错window is not defined 原因：Nuxt 在服务端渲染时找不到 window 查询官网文档： 解决办法：在 nuxt 的 plugins 目录下新建 vue-awesome-swiper.js 文件，代码如下： 123456import Vue from \"vue\";import \"swiper/dist/css/swiper.css\";if (process.browser) { const VueAwesomeSwiper = require(\"vue-awesome-swiper/dist/ssr\"); Vue.use(VueAwesomeSwiper);} 修改 nuxt.config.js 的 plugins 配置： 在 nuxt.config.js 的 plugins 里加入： 1234{ src: \"@/plugins/vue-awesome-swiper\", ssr: false} IndexBanner.vue 的代码为： 1234567&lt;div v-swiper:mySwiper=\"swiperOption\" class=\"swiper\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\"&gt;1&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;2&lt;/div&gt; &lt;/div&gt; &lt;div class=\"swiper-pagination\"&gt;&lt;/div&gt;&lt;/div&gt;","link":"/2020/01/14/vue-awesome-swiper%E6%8A%A5%E9%94%99%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"title":"Vue @mousemove实现拖动，鼠标移动过快拖动卡顿","text":"需求使用 vue 实现滑动拼图验证码 踩到的坑使用@mousemove 绑定事件拖拽速度过快有严重的卡顿 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;template&gt; &lt;div class=\"slider-verify\"&gt; &lt;div class=\"img\"&gt; &lt;img src=\"./101.jpg\" class=\"big-img\" /&gt; &lt;img ref=\"block\" src=\"./101.jpg\" class=\"small-img\" @mousemove=\"handleDragMove\" @mousedown=\"handleDragStart\" @mouseup=\"handleDragEnd\" /&gt; &lt;/div&gt; &lt;div ref=\"sliderContainer\" class=\"sliderContainer\"&gt; &lt;div ref=\"sliderMask\" class=\"sliderMask\"&gt; &lt;div ref=\"slider\" class=\"slider\"&gt; &lt;i class=\"el-icon-right\" @mousemove=\"handleDragMove\" @mousedown=\"handleDragStart\" @mouseup=\"handleDragEnd\" &gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;span class=\"sliderText\"&gt;向右滑动填充拼图&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: \"SliderVerify\", props: { width: { type: Number, default: 310 } }, data() { return { isMouseDown: false, originX: 0, originY: 0, slider: null, sliderMask: null, sliderContainer: null, block: null }; }, created() { this.$nextTick(() =&gt; { this.slider = this.$refs.slider; this.sliderMask = this.$refs.sliderMask; this.sliderContainer = this.$refs.sliderContainer; this.block = this.$refs.block; }); }, methods: { handleDragMove(e) { if (!this.isMouseDown) return false; const w = this.width; // 获取拖拽移动的距离 const eventX = e.clientX || e.touches[0].clientX; const moveX = eventX - this.originX; if (moveX &lt; 0 || moveX + 40 &gt;= w) return false; this.slider.style.left = moveX + \"px\"; this.block.style.left = moveX + \"px\"; this.sliderMask.style.width = moveX + \"px\"; }, handleDragStart(e) { // 获取拖拽起始位置坐标 this.originX = e.clientX || e.touches[0].clientX; this.originY = e.clientY || e.touches[0].clientY; this.isMouseDown = true; }, handleDragEnd(e) { if (!this.isMouseDown) return false; this.isMouseDown = false; const eventX = e.clientX || e.changedTouches[0].clientX; if (eventX === this.originX) return false; } } };&lt;/script&gt;... 解决方案使用 JS 原生事件替代 Vue v-on 事件 优化后代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;template&gt; &lt;div class=\"slider-verify\"&gt; &lt;div class=\"img\"&gt; &lt;img src=\"./101.jpg\" class=\"big-img\" /&gt; &lt;img ref=\"block\" src=\"./101.jpg\" class=\"small-img\" @mousedown=\"handleDragStart\" /&gt; &lt;/div&gt; &lt;div ref=\"sliderContainer\" class=\"sliderContainer\"&gt; &lt;div ref=\"sliderMask\" class=\"sliderMask\"&gt; &lt;div ref=\"slider\" class=\"slider\"&gt; &lt;i class=\"el-icon-right\" @mousedown=\"handleDragStart\"&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;span class=\"sliderText\"&gt;向右滑动填充拼图&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: \"SliderVerify\", props: { width: { type: Number, default: 310 } }, data() { return { isMouseDown: false, originX: 0, originY: 0, slider: null, sliderMask: null, sliderContainer: null, block: null }; }, created() { this.$nextTick(() =&gt; { this.slider = this.$refs.slider; this.sliderMask = this.$refs.sliderMask; this.sliderContainer = this.$refs.sliderContainer; this.block = this.$refs.block; }); }, methods: { handleDragStart(e) { // 获取拖拽起始位置坐标 this.originX = e.clientX || e.touches[0].clientX; this.originY = e.clientY || e.touches[0].clientY; this.isMouseDown = true; document.onmousemove = ev =&gt; { if (!this.isMouseDown) return false; const w = this.width; // 获取拖拽移动的距离 const eventX = ev.clientX || ev.touches[0].clientX; const moveX = eventX - this.originX; if (moveX &lt; 0 || moveX + 40 &gt;= w) return false; this.slider.style.left = moveX + \"px\"; this.block.style.left = moveX + \"px\"; this.sliderMask.style.width = moveX + \"px\"; }; document.onmouseup = ev =&gt; { if (!this.isMouseDown) return false; this.isMouseDown = false; const eventX = ev.clientX || ev.changedTouches[0].clientX; if (eventX === this.originX) return false; }; } } };&lt;/script&gt;... 优化后效果 Ending……","link":"/2020/01/14/vue%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%8A%A8%E8%BF%87%E5%BF%AB%E6%8B%96%E5%8A%A8%E5%8D%A1%E9%A1%BF/"},{"title":"音乐作品《我只在乎你（Cover：邓丽君）》","text":"&emsp;&emsp;这是一首由近代日本作曲家三木たかし与填词人荒木とよひさ共同为邓丽君打造的一首音乐作品，每次听到这首作品都会感动很久。&emsp;&emsp;这首歌原本是一首大调歌曲，我把他改编成了小调转大调，主歌的和弦几乎全被我换掉了，听惯了大调，所以我想尝试一下暗淡的色彩会不会给这首歌带来新的味道。&emsp;&emsp;这次改编我只用了一架钢琴作为伴奏乐器，使用的和弦其实并没有很复杂，大都是简单的离调，为了丰富 jazz 味道，我在钢琴节奏方面用了 swing，可能用了 swing 后 jazz 味道会浓郁一些（但是我又不想让它太浓）！&emsp;&emsp;请原谅我的唱功，我承认，我的唱功确实垃圾到爆了，又不会爵士唱法，实在惨不忍睹 😅，希望各位不要被我的唱功劝退！ 歌词作曲：荒木とよひさ作词：三木たかし改编：木荣如果没有遇见你我将会是在哪里日子过得怎么样人生是否要珍惜 也许认识某一人过着平凡的日子不知道会不会也有爱情甜如蜜 任时光匆匆流去我只在乎你心甘情愿感染你的气息人生几何能够得到知己失去生命的力量也不可惜所以我求求你别让我离开你除了你 我不能感到一丝丝情意","link":"/2020/01/15/%E3%80%8A%E6%88%91%E5%8F%AA%E5%9C%A8%E4%B9%8E%E4%BD%A0%EF%BC%88Cover%EF%BC%9A%E9%82%93%E4%B8%BD%E5%90%9B%EF%BC%89%E3%80%8B/"},{"title":"使用vue3+typescript编写一个图片懒加载插件","text":"本插件主要功能借鉴于：vue-lazyload github项目地址: https://github.com/murongg/vue3-lazyload 求star 与 issues 我文采不好，可能写的文章不咋样，有什么问题可以在留言区评论，我会尽力解答 本项目已经发布到npm 安装： 123$ npm i vue3-lazyload# or$ yarn add vue3-lazyload 需求分析 支持自定义 loading 图片，图片加载状态时使用此图片 支持自定义 error 图片，图片加载失败后使用此图片 支持 lifecycle hooks，类似于 vue 的生命周期，并同时在 img 标签绑定 lazy 属性，类似于 123&lt;img src=\"...\" lazy=\"loading\"&gt;&lt;img src=\"...\" lazy=\"loaded\"&gt;&lt;img src=\"...\" lazy=\"error\"&gt; 并支持： 123456789img[lazy=loading] { /*your style here*/}img[lazy=error] { /*your style here*/}img[lazy=loaded] { /*your style here*/} 支持使用 v-lazy 自定义指令，指定可传入 string/object ，当为 string 时，默认为需要加载的 url，当为 object 时，可传入 src: 当前需要加载的图片 url loading: 加载状态时所用到的图片 error: 加载失败时所用到的图片 lifecycle: 本次 lazy 的生命周期，替换掉全局生命周期 目录结构12345- src---- index.ts 入口文件，主要用来注册插件---- lazy.ts 懒加载主要功能---- types.ts 类型文件，包括 interface/type/enum 等等---- util.ts 共享工具文件 编写懒加载类懒加载主要通过 IntersectionObserver对象实现，可能有些浏览器不支持，暂未做兼容。 确定注册插件时传入的参数types.ts： 123456789101112131415161718192021222324export interface LazyOptions { error?: string; // 加载失败时的图片 loading?: string; // 加载中的图片 observerOptions?: IntersectionObserverInit; // IntersectionObserver 对象传入的第二个参数 log?: boolean; // 是否需要打印日志 lifecycle?: Lifecycle; // 生命周期 hooks}export interface ValueFormatterObject { src: string, error?: string, loading?: string, lifecycle?: Lifecycle;}export enum LifecycleEnum { LOADING = 'loading', LOADED = 'loaded', ERROR = 'error'}export type Lifecycle = { [x in LifecycleEnum]?: () =&gt; void;}; 确定类的框架vue3 的 Custom Directives，支持以下 Hook Functions：beforeMount 、mounted、beforeUpdate、updated、beforeUnmount、unmounted，具体释义可以去 vue3 文档查看，目前仅需要用到mounted、updated、unmounted，这三个 Hook。 Lazy 类基础框架代码，lazy.ts： 12345678910111213141516171819202122232425262728export default class Lazy { public options: LazyOptions = { loading: DEFAULT_LOADING, error: DEFAULT_ERROR, observerOptions: DEFAULT_OBSERVER_OPTIONS, log: true, lifecycle: {} }; constructor(options?: LazyOptions) { this.config(options) } /** * merge config * assgin 方法在 util.ts 文件内，此文章不在赘述此方法代码，可在后文 github 仓库内查看此代码 * 此方法主要功能是合并两个对象 * * @param {*} [options={}] * @memberof Lazy */ public config(options = {}): void { assign(this.options, options) } public mount(el: HTMLElement, binding: DirectiveBinding&lt;string | ValueFormatterObject&gt;): void {} // 对应 directive mount hook public update() {} // 对应 directive update hook public unmount() {} // 对应 directive unmount hook} 编写懒加载功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171/** * mount * * @param {HTMLElement} el * @param {DirectiveBinding&lt;string&gt;} binding * @memberof Lazy */public mount(el: HTMLElement, binding: DirectiveBinding&lt;string | ValueFormatterObject&gt;): void { this._image = el const { src, loading, error, lifecycle } = this._valueFormatter(binding.value) this._lifecycle(LifecycleEnum.LOADING, lifecycle) this._image.setAttribute('src', loading || DEFAULT_LOADING) if (!hasIntersectionObserver) { this.loadImages(el, src, error, lifecycle) this._log(() =&gt; { throw new Error('Not support IntersectionObserver!') }) } this._initIntersectionObserver(el, src, error, lifecycle)}/** * force loading * * @param {HTMLElement} el * @param {string} src * @memberof Lazy */public loadImages(el: HTMLElement, src: string, error?: string, lifecycle?: Lifecycle): void { this._setImageSrc(el, src, error, lifecycle)}/** * set img tag src * * @private * @param {HTMLElement} el * @param {string} src * @memberof Lazy */private _setImageSrc(el: HTMLElement, src: string, error?: string, lifecycle?: Lifecycle): void { const srcset = el.getAttribute('srcset') if ('img' === el.tagName.toLowerCase()) { if (src) el.setAttribute('src', src) if (srcset) el.setAttribute('srcset', srcset) this._listenImageStatus(el as HTMLImageElement, () =&gt; { this._log(() =&gt; { console.log('Image loaded successfully!') }) this._lifecycle(LifecycleEnum.LOADED, lifecycle) }, () =&gt; { // Fix onload trigger twice, clear onload event // Reload on update el.onload = null this._lifecycle(LifecycleEnum.ERROR, lifecycle) this._observer.disconnect() if (error) el.setAttribute('src', error) this._log(() =&gt; { throw new Error('Image failed to load!') }) }) } else { el.style.backgroundImage = 'url(\\'' + src + '\\')' }}/** * init IntersectionObserver * * @private * @param {HTMLElement} el * @param {string} src * @memberof Lazy */private _initIntersectionObserver(el: HTMLElement, src: string, error?: string, lifecycle?: Lifecycle): void { const observerOptions = this.options.observerOptions this._observer = new IntersectionObserver((entries) =&gt; { Array.prototype.forEach.call(entries, (entry) =&gt; { if (entry.isIntersecting) { this._observer.unobserve(entry.target) this._setImageSrc(el, src, error, lifecycle) } }) }, observerOptions) this._observer.observe(this._image)}/** * only listen to image status * * @private * @param {string} src * @param {(string | null)} cors * @param {() =&gt; void} success * @param {() =&gt; void} error * @memberof Lazy */private _listenImageStatus(image: HTMLImageElement, success: ((this: GlobalEventHandlers, ev: Event) =&gt; any) | null, error: OnErrorEventHandler) { image.onload = success image.onerror = error}/** * to do it differently for object and string * * @public * @param {(ValueFormatterObject | string)} value * @returns {*} * @memberof Lazy */public _valueFormatter(value: ValueFormatterObject | string): ValueFormatterObject { let src = value as string let loading = this.options.loading let error = this.options.error let lifecycle = this.options.lifecycle if (isObject(value)) { src = (value as ValueFormatterObject).src loading = (value as ValueFormatterObject).loading || this.options.loading error = (value as ValueFormatterObject).error || this.options.error lifecycle = ((value as ValueFormatterObject).lifecycle || this.options.lifecycle) } return { src, loading, error, lifecycle }}/** * log * * @param {() =&gt; void} callback * @memberof Lazy */public _log(callback: () =&gt; void): void { if (!this.options.log) { callback() }}/** * lifecycle easy * * @private * @param {LifecycleEnum} life * @param {Lifecycle} [lifecycle] * @memberof Lazy */private _lifecycle(life: LifecycleEnum, lifecycle?: Lifecycle): void { switch (life) { case LifecycleEnum.LOADING: this._image.setAttribute('lazy', LifecycleEnum.LOADING) if (lifecycle?.loading) { lifecycle.loading() } break case LifecycleEnum.LOADED: this._image.setAttribute('lazy', LifecycleEnum.LOADED) if (lifecycle?.loaded) { lifecycle.loaded() } break case LifecycleEnum.ERROR: this._image.setAttribute('lazy', LifecycleEnum.ERROR) if (lifecycle?.error) { lifecycle.error() } break default: break }} 编写 update hook1234567891011/** * update * * @param {HTMLElement} el * @memberof Lazy */public update(el: HTMLElement, binding: DirectiveBinding&lt;string | ValueFormatterObject&gt;): void { this._observer.unobserve(el) const { src, error, lifecycle } = this._valueFormatter(binding.value) this._initIntersectionObserver(el, src, error, lifecycle)} 编写 unmount hook123456789/** * unmount * * @param {HTMLElement} el * @memberof Lazy */public unmount(el: HTMLElement): void { this._observer.unobserve(el)} 在 index.ts 编写注册插件需要用到的 install 方法123456789101112131415161718192021222324252627import Lazy from './lazy'import { App } from 'vue'import { LazyOptions } from './types'export default { /** * install plugin * * @param {App} Vue * @param {LazyOptions} options */ install (Vue: App, options: LazyOptions): void { const lazy = new Lazy(options) Vue.config.globalProperties.$Lazyload = lazy // 留着备用，为了兼容$Lazyload // 选项api，可以通过this.$Lazyload获取到Lazy类的实例，组合api我还不知道怎么获取 // 所以通过 provide 来实现此需求 // 使用方式 const useLazylaod = inject('Lazyload') Vue.provide('Lazyload', lazy) Vue.directive('lazy', { mounted: lazy.mount.bind(lazy), updated: lazy.update.bind(lazy), unmounted: lazy.unmount.bind(lazy) }) }} 使用插件Main.js: 1234567891011121314151617181920import { createApp } from 'vue'import App from './App.vue'import VueLazyLoad from '../src/index'const app = createApp(App)app.use(VueLazyLoad, { log: true, lifecycle: { loading: () =&gt; { console.log('loading') }, error: () =&gt; { console.log('error') }, loaded: () =&gt; { console.log('loaded') } }})app.mount('#app') App.vue: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div class=&quot;margin&quot; /&gt; &lt;img v-lazy=&quot;'/example/assets/logo.png'&quot; alt=&quot;Vue logo&quot; width=&quot;100&quot;&gt; &lt;img v-lazy=&quot;{src: errorlazy.src, lifecycle: errorlazy.lifecycle}&quot; alt=&quot;Vue logo&quot; class=&quot;image&quot; width=&quot;100&quot;&gt; &lt;button @click=&quot;change&quot;&gt; change &lt;/button&gt;&lt;/template&gt;&lt;script&gt;import { reactive } from 'vue'export default { name: 'App', setup() { const errorlazy = reactive({ src: '/example/assets/log1o.png', lifecycle: { loading: () =&gt; { console.log('image loading') }, error: () =&gt; { console.log('image error') }, loaded: () =&gt; { console.log('image loaded') } } }) const change = () =&gt; { errorlazy.src = 'http://t8.baidu.com/it/u=3571592872,3353494284&amp;fm=79&amp;app=86&amp;size=h300&amp;n=0&amp;g=4n&amp;f=jpeg?sec=1603764281&amp;t=bedd2d52d62e141cbb08c462183601c7' } return { errorlazy, change } }}&lt;/script&gt;&lt;style&gt;.margin { margin-top: 1000px;}.image[lazy=loading] { background: goldenrod;}.image[lazy=error] { background: red;}.image[lazy=loaded] { background: green;}&lt;/style&gt;","link":"/2020/10/23/%E4%BD%BF%E7%94%A8vue3-typescript%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E6%8F%92%E4%BB%B6/"},{"title":"爬取某站所有性感美女图片（NodeJs版）","text":"准备工作环境 node v10.13.0 npm v6.4.1项目依赖 request-promise（网络请求promise版） cheerio（dom操作） fs（文件读写）其他路径12const BASE_URL = \"http://www.umei.cc/p/gaoqing/cn/\"; // 目标站地址const BASE_PATH = \"D://picture//\"; // 需要存储到的文件夹 headers设置1234const headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36\"}; 开始首页分析 编写页码遍历代码在首页我们需要获取每一篇图集的完整URL地址，和首页列表的页码。 点击末页可以发现一共有26页，写死就好了，现在可以编写第一步的代码了。 123456789101112/** * 一共有26页，提前做好遍历，并拼接URL * */async function getPageList() { for (let index = 1; index &lt;= 26; index++) { // 最终URL示例http://www.umei.cc/p/gaoqing/cn/26.htm const url = `${BASE_URL}${index}.htm`; // 下一步所需操作方法 await getPageUrl(url); }} 接下来就要获取每个图集的详情URL地址 根据dom可以发现详情的a标签地址在.TypeList ul li a.TypeBigPics的href里 编写获取图集详情地址代码1234567891011121314151617181920/** * 获取每一页的列表URL * * @param {*} baseUrl */async function getPageUrl(baseUrl) { const body = await request({ url: baseUrl }); const $ = cheerio.load(body); const urls = $(\".TypeList ul li a.TypeBigPics\"); urls.each(async function() { const url = $(this).attr(\"href\"); console.log(url); if (url) { // 下一操作，获取每篇图集的所有页码链接 await getDetailUrl(url); } });} 详情页分析现在我们就可以进入图集详情页了，在图集详情页依然要获取详细的页码信息，以此获取到图集的所有图片，并且下载到本地。 获取页码 这次我们不能将页码写死了，要取出dom.NewPages ul li a里的共与页之间的数字，这里要注意，取出来的值是String类型，我们要把他转为Number类型，取到页码后，还需要将每个图集的title取出来，用来生成需要保存图片到的文件夹。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 获取每篇图集的所有链接 * * @param {*} url * @returns */async function getDetailUrl(url) { const body = await request({ url: url }); const $ = cheerio.load(body); // 正则获取有多少页 const count = Number( $(\".NewPages ul li a\") .first() .text() .match(/共(\\S*)页/)[1] ); // 生成要保存的图片文件夹 const path = BASE_PATH + $(\".ArticleTitle\") .text() .trim(); const isMkdir = mkdirFolder(path); if (!isMkdir) { return; } let defaultUrl = url.split(\".htm\")[0]; // 遍历页码，生成图集详情页每一页的URL for (let index = 1; index &lt;= count; index++) { let endUrl = \"\"; if (index === 1) { endUrl = defaultUrl + \".htm\"; } else { endUrl = `${defaultUrl}_${index}.htm`; } // 下一操作，获取每一页图片的URL地址 await getDetail(endUrl, path); }} 创建文件夹方法封装1234567891011121314151617/** * 创建文件夹 * * @param {*} path * @returns */function mkdirFolder(path) { if (!fs.existsSync(path)) { //查看是否存在这个文件夹 fs.mkdirSync(path); //不存在就建文件夹 console.log(`${path}文件夹创建成功`); return true; } else { console.log(`${path}文件夹已经存在`); return true; }} 获取图集详情每页图片的URL 由图可见，我们需要获取.ImageBody p a img的src属性。 1234567891011121314151617181920/** * 获取每一页的图片URL * * @param {*} detailUrl * @returns */async function getDetail(detailUrl, path) { const body = await request({ url: detailUrl, headers }); const $ = cheerio.load(body); const imgUrl = $(\".ImageBody p a img\").attr(\"src\"); if (imgUrl) { const imgTitle = imgUrl.split(\"/\").pop(); // 下一操作，保存图片到本地 await getImage(imgUrl, imgTitle, path); }} 保存图片方法利用fs库，进行文件操作 1234567891011121314151617/** * 获取每一页所有图片 * * @param {*} imgUrl * @param {*} imgTitle * @param {*} path */async function getImage(imgUrl, imgTitle, path) { const imgRes = await request({ url: imgUrl, headers, resolveWithFullResponse: true }).pipe(fs.createWriteStream(`${path}/${imgTitle}`)); if (imgRes) { console.log(`[${imgTitle}]保存成功`); }} 运行1node meinv.js 不得不说，js的异步太恶心了，图片一张没下载下来，文件夹全给我建完了。 再看看带宽占用。 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142const request = require(\"request-promise\"); // 网络请求const cheerio = require(\"cheerio\"); // 操作domconst fs = require(\"fs\"); // 读写文件const BASE_URL = \"http://www.umei.cc/p/gaoqing/cn/\"; // 目标站地址const BASE_PATH = \"D://picture//\"; // 需要存储到的文件夹const headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36\"};/** * 一共有26页，提前做好遍历，并拼接URL * */async function getPageList() { for (let index = 1; index &lt;= 26; index++) { // 最终URL示例http://www.umei.cc/p/gaoqing/cn/26.htm const url = `${BASE_URL}${index}.htm`; // 下一步所需操作方法 await getPageUrl(url); }}/** * 获取每一页的列表URL * * @param {*} baseUrl */async function getPageUrl(baseUrl) { const body = await request({ url: baseUrl }); const $ = cheerio.load(body); const urls = $(\".TypeList ul li a.TypeBigPics\"); urls.each(async function() { const url = $(this).attr(\"href\"); if (url) { // 下一操作，获取每篇图集的所有页码链接 await getDetailUrl(url); } });}/** * 获取每篇图集的所有链接 * * @param {*} url * @returns */async function getDetailUrl(url) { const body = await request({ url: url }); const $ = cheerio.load(body); // 正则获取有多少页 const count = Number( $(\".NewPages ul li a\") .first() .text() .match(/共(\\S*)页/)[1] ); // 生成要保存的图片文件夹 const path = BASE_PATH + $(\".ArticleTitle\") .text() .trim(); const isMkdir = mkdirFolder(path); if (!isMkdir) { return; } let defaultUrl = url.split(\".htm\")[0]; // 遍历页码，生成图集详情页每一页的URL for (let index = 1; index &lt;= count; index++) { let endUrl = \"\"; if (index === 1) { endUrl = defaultUrl + \".htm\"; } else { endUrl = `${defaultUrl}_${index}.htm`; } // 下一操作，获取每一页图片的URL地址 await getDetail(endUrl, path); }}/** * 获取每一页的图片URL * * @param {*} detailUrl * @returns */async function getDetail(detailUrl, path) { const body = await request({ url: detailUrl, headers }); const $ = cheerio.load(body); const imgUrl = $(\".ImageBody p a img\").attr(\"src\"); if (imgUrl) { const imgTitle = imgUrl.split(\"/\").pop(); // 下一操作，保存图片到本地 await getImage(imgUrl, imgTitle, path); }}/** * 获取每一页所有图片 * * @param {*} imgUrl * @param {*} imgTitle * @param {*} path */async function getImage(imgUrl, imgTitle, path) { const imgRes = await request({ url: imgUrl, headers, resolveWithFullResponse: true }).pipe(fs.createWriteStream(`${path}/${imgTitle}`)); if (imgRes) { console.log(`[${imgTitle}]保存成功`); }}/** * 创建文件夹 * * @param {*} path * @returns */function mkdirFolder(path) { if (!fs.existsSync(path)) { //查看是否存在这个文件夹 fs.mkdirSync(path); //不存在就建文件夹 console.log(`${path}文件夹创建成功`); return true; } else { console.log(`${path}文件夹已经存在`); return true; }}getPageList();","link":"/2020/01/20/%E7%88%AC%E5%8F%96%E6%9F%90%E7%AB%99%E6%89%80%E6%9C%89%E6%80%A7%E6%84%9F%E7%BE%8E%E5%A5%B3%E5%9B%BE%E7%89%87%EF%BC%88NodeJs%E7%89%88%EF%BC%89/"},{"title":"爬取某站所有性感美女图片（Python版）","text":"Python 版环境 python3.7 pip19.3 依赖 requests pyquery os 前期准备引入所需依赖1234import requestsimport osfrom requests.packages import urllib3from pyquery import PyQuery as pq headers 设置（重要）12345headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) ' 'AppleWebKit/537.36 (KHTML, like Gecko)' 'Chrome/58.0.3029.110 Safari/537.36'} 目标站http://www.umei.cc/p/gaoqing/cn/ 获取需要爬取页面的地址1234567891011121314151617181920212223def get_detail(url): \"\"\" 获取需要爬取页面的地址 :param url: :return: \"\"\" urllib3.disable_warnings() html = requests.get(url, headers=headers, verify=False) html.encoding = 'utf-8' code = html.status_code if code == 404: print('本页面URL已爬取结束') return code doc = pq(html.text) a = doc('.TypeBigPics') print(a) end_list = [] for item in a.items(): url_result = item.attr('href') result = 'htm' in url_result.split('/')[-1] if result: end_list.append(url_result.split('.htm')[0]) return end_list 获取每一页所有图片123456789101112131415161718192021222324252627282930313233343536def get_img(url): \"\"\" 获取每一页所有图片 :param url: :return: \"\"\" urllib3.disable_warnings() html = requests.get(url, headers=headers, verify=False) html.encoding = 'utf-8' code = html.status_code if code == 404: print('本页面图片已爬取结束') return True doc = pq(html.text) img = doc('.wrap .ImageBody a img') img_title = img.attr('alt') if not img_title: return True img_url = img.attr('src') root = \"图片文件夹路径（需提前建好）//\" + img_title + '/' path = root + img_url.split('/')[-1] # 根目录加上url中以反斜杠分割的最后一部分，即可以以图片原来的名字存储在本地 try: if not os.path.exists(root): # 判断当前根目录是否存在 print('创建根目录') os.mkdir(root) # 创建根目录 if not os.path.exists(path): # 判断文件是否存在 r = requests.get(img_url) with open(path, 'wb')as f: f.write(r.content) f.close() print(\"文件保存成功\", '\\n', '\\n') else: print(\"文件已存在\") except: print(\"爬取失败\") main 主函数12345678910111213141516171819if __name__ == '__main__': z = 1 n = 1 url = 'http://www.umei.cc/p/gaoqing/cn/' for d in range(n, 26): # 提前看好了 一共有26页，所以提前设置好循环次数 pa_url = '{0}{1}.htm'.format(url, d) print(pa_url) result = get_detail(pa_url) for e in result: for i in range(z, 100): if i == 1: url1 = e + '.htm' else: url1 = e + '_' + str(i) + '.htm' is_end = get_img(url1) # 如果状态码为404，则进行下次循环 if is_end == True: break 成果","link":"/2020/01/18/%E7%88%AC%E5%8F%96%E6%9F%90%E7%AB%99%E6%89%80%E6%9C%89%E6%80%A7%E6%84%9F%E7%BE%8E%E5%A5%B3%E5%9B%BE%E7%89%87%EF%BC%88Python%E7%89%88%EF%BC%89/"},{"title":"简单工厂模式","text":"简介工厂模式主要是为了创建对象实例或者类簇(抽象工厂), 关心的是最终产出(创建)的对象, 而不关心创建的过程. 在出现多个类的时候, 每次创建需要找到对应的类往往比较麻烦, 这时候通常使用一个函数进行封装来创建所需要的对象,这样就无需关注创建这些对象到底依赖哪些基类了, 只要知道有这个函数就可以了, 通常这个函数被称为工厂函数,这种模式叫简单工厂模式 案例假设一体育商品店卖器材, 里面有很多体育商品, 及其相关介绍. 当你来到体育用品店买一个篮球及相关介绍时,你只需要问售货员, 她会帮你找到你所需要的东西. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var Basketball = function() { this.intro = \"篮球盛行于美国\";};Basketball.prototype = { getMember() { console.log(\"每个队伍需要5名队员\"); }, getBallSize() { console.log(\"篮球很大\"); }};// 足球基类var Football = function() { this.intro = \"足球在世界范围内盛行\";};Football.prototype = { getMember() { console.log(\"每个队伍需要11名队员\"); }, getBallSize() { console.log(\"足球很大\"); }}; // 网球基类var Tennis = function() { this.intro = \"每年有很多网球系列赛\";};Tennis.prototype = { getMember() { console.log(\"每个队伍需要1名队员\"); }, getBallSize() { console.log(\"网球很小\"); }}; // 运动工厂(这边相当于咨询体育器材店的售货员, 告诉她你想要买什么体育用品)var SportFactory = function(name) { switch (name) { case \"basketball\": return new Basketball(); case \"football\": return new Football(); case \"tennis\": return new Tennis(); }};var ball = new SportFactory(\"basketball\");console.log(ball.intro); // 篮球盛行于美国ball.getBallSize(); // 篮球很大","link":"/2020/01/19/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"title":"谈一谈4536251万能和声进行","text":"前言&emsp;&emsp;2018 年，4536251这串数字因为某截火了起来，很多吃瓜群众的口袋里又多了一个“网络生化武器”。在专业的音乐制作人眼里，这只不过是一套烂大街的和声进行，又称万能和声进行，或者说是黄金八小节。现在，我们简单的谈一谈这套和声进行。 关于 4536251&emsp;&emsp;4536251转换为现代和声标记为F、G、Em、Am、Dm、G、C（C 调示例，以下所有和弦代号均用 C 调示例），基础好的朋友可能会发现，如果将第二个和弦G换成Bdim，正好可以组成一个向上四度进行的排列F、Bdim、Em、Am、Dm、G、C，基础更好的朋友可能还会发现，将这套和声进行倒过来排列C、G、Dm、Am、Em、Bdim、F，正好形成一个五度圈，有的人认为4536251是五度圈倒过来的排列，所以也会称4536251为四度圈，各持己见。 &emsp;&emsp;上一段落我们说到将G换成Bdim，其实这套进行原本的样子便是F、Bdim、Em、Am、Dm、G、C，但是为什么将Bdim换成G呢？因为Bdim是一个极具阴暗色彩的和弦，它的组成音ti(7)、re(2)、fa(4)正好组成一个三全音，极不协和，在普通流行音乐中，听众很难接受这种色彩的和弦，但是Bdim在爵士和声中是一个具有属功能的和弦，所以创作者们便把这个和弦换成了同样具有属功能的五级和弦G，这是十分合理的。&emsp;&emsp;继续研究剩下的几个和弦，根据爵士和声251终止式可以发现，他们为自己下一个和弦的属和弦，比如第三个和弦Em，将它换成E7后，它是第四个和弦Am的五级和弦；第四个和弦Am替换成A7，便是第五个和弦Dm的五级和弦，其余一式一样。因为在稳定和不稳定之间的切换听起来就很舒服，所以很多创作者会为了丰富和声色彩，会将这些和弦来回替换，从而达到他们的目的（比如F、G、E7、Am、Dm、G7、C、F、G、Em、A7、Dm、G7、C……）。 Ending……&emsp;&emsp;根据以上讨论会发现，这是一套完全合理，没有任何听感乃至理论错误的和声进行，这就是4536251为什么这么受欢迎的原因。&emsp;&emsp;其实在早期甚至说现在，很多著名音乐人都在用这套和声进行创作，比如：周杰伦，林俊杰，王力宏……，其实并不是这套和声进行烂大街，而是现在的创作者都很浮躁，在自己理论基础不是很扎实，且创作旋律天赋不是很高的情况下，简单学习一些基础的和声知识，生搬硬套的进行创作，只会在创作旋律时使用和弦内音，不懂得变通，不能很完美的利用它玩出更多的花样，导致写出的旋律听上去都很熟悉，好像是抄的别人的似的。 给喜欢创作的朋友的建议&emsp;&emsp;请各位创作的朋友们，在准备创作之前，请打好乐理基础，不然自己都不知道自己写的是什么。有人会说：那些大师们有几个创作是根据乐理来的！大哥们，请你们瞪大眼睛看看，有哪个大师乐理不是超级牛皮的，只有在乐理很厉害的情况下，才能不出现任何错误的脱离理论进行创作。&emsp;&emsp;各位朋友们，勿焦虑，勿浮躁！在这个浮夸的社会里，静下心做自己喜欢的事是多么快乐，既然喜欢就一定要认真去做，请不要滥竽充数。","link":"/2020/01/16/%E8%B0%88%E4%B8%80%E8%B0%884536251%E4%B8%87%E8%83%BD%E5%92%8C%E5%A3%B0%E8%BF%9B%E8%A1%8C/"},{"title":"音乐作品《月半弯（Cover：陈坤）》","text":"&emsp;&emsp;这是一首普通的流行歌曲，由郝雷作词作曲，张学友演唱，1985 年发行，我把它改编成了偏 R&amp;B 的风格。和弦方面没有太大的改动，最多就是在原有和弦加了几个色彩音！&emsp;&emsp;第一次接触到这首歌是听了皮皮改编的版本，他改编成的风格好像是 Soul，听了之后我就喜欢上了这首歌。个人比较喜欢皮皮改编的版本，毕竟二十年前的编曲实在难征服我的耳朵！ 歌词作曲：郝雷作词：郝雷改编：木荣编曲：木荣那夜真的好浪漫我带你去看月半弯有点害羞 却很幸福这种感觉我很喜欢 让我温柔靠近你身边你也轻轻陷入我臂弯感觉爱情 悄悄来临纷纷扰扰与我无关 夜色中两人用渴望眼神交换原来恋爱现场感觉不像想的那样主观 月半弯 好浪漫月光下的你显得特别的好看月半弯 我喜欢有情 有意 有你还有甜","link":"/2020/01/15/%E9%9F%B3%E4%B9%90%E4%BD%9C%E5%93%81%E3%80%8A%E6%9C%88%E5%8D%8A%E5%BC%AF%EF%BC%88Cover%EF%BC%9A%E9%99%88%E5%9D%A4%EF%BC%89%E3%80%8B/"}],"tags":[{"name":"冒泡排序","slug":"冒泡排序","link":"/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Web Api","slug":"Web-Api","link":"/tags/Web-Api/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"BOM","slug":"BOM","link":"/tags/BOM/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"事件","slug":"事件","link":"/tags/%E4%BA%8B%E4%BB%B6/"},{"name":"事件代理","slug":"事件代理","link":"/tags/%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86/"},{"name":"事件冒泡","slug":"事件冒泡","link":"/tags/%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/"},{"name":"JavaScript基础","slug":"JavaScript基础","link":"/tags/JavaScript%E5%9F%BA%E7%A1%80/"},{"name":"变量","slug":"变量","link":"/tags/%E5%8F%98%E9%87%8F/"},{"name":"闭包","slug":"闭包","link":"/tags/%E9%97%AD%E5%8C%85/"},{"name":"作用域","slug":"作用域","link":"/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"原型","slug":"原型","link":"/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"原型链","slug":"原型链","link":"/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"异步","slug":"异步","link":"/tags/%E5%BC%82%E6%AD%A5/"},{"name":"Koa","slug":"Koa","link":"/tags/Koa/"},{"name":"cms","slug":"cms","link":"/tags/cms/"},{"name":"后端","slug":"后端","link":"/tags/%E5%90%8E%E7%AB%AF/"},{"name":"RESTFUL","slug":"RESTFUL","link":"/tags/RESTFUL/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Vue源码分析","slug":"Vue源码分析","link":"/tags/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"库","slug":"库","link":"/tags/%E5%BA%93/"},{"name":"Nuxt","slug":"Nuxt","link":"/tags/Nuxt/"},{"name":"Jazz","slug":"Jazz","link":"/tags/Jazz/"},{"name":"Vue3","slug":"Vue3","link":"/tags/Vue3/"},{"name":"懒加载","slug":"懒加载","link":"/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"4536251","slug":"4536251","link":"/tags/4536251/"},{"name":"万能和声进行","slug":"万能和声进行","link":"/tags/%E4%B8%87%E8%83%BD%E5%92%8C%E5%A3%B0%E8%BF%9B%E8%A1%8C/"},{"name":"R&B","slug":"R-B","link":"/tags/R-B/"}],"categories":[{"name":"Golang","slug":"Golang","link":"/categories/Golang/"},{"name":"程序世界","slug":"程序世界","link":"/categories/%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C/"},{"name":"算法","slug":"Golang/算法","link":"/categories/Golang/%E7%AE%97%E6%B3%95/"},{"name":"JavaScript","slug":"程序世界/JavaScript","link":"/categories/%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C/JavaScript/"},{"name":"WEB后端","slug":"程序世界/WEB后端","link":"/categories/%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C/WEB%E5%90%8E%E7%AB%AF/"},{"name":"WEB前端","slug":"程序世界/WEB前端","link":"/categories/%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C/WEB%E5%89%8D%E7%AB%AF/"},{"name":"音乐世界","slug":"音乐世界","link":"/categories/%E9%9F%B3%E4%B9%90%E4%B8%96%E7%95%8C/"},{"name":"Vue","slug":"程序世界/JavaScript/Vue","link":"/categories/%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C/JavaScript/Vue/"},{"name":"NodeJs","slug":"程序世界/NodeJs","link":"/categories/%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C/NodeJs/"},{"name":"python","slug":"程序世界/python","link":"/categories/%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C/python/"},{"name":"设计模式","slug":"程序世界/设计模式","link":"/categories/%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"NodeJs","slug":"程序世界/WEB后端/NodeJs","link":"/categories/%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C/WEB%E5%90%8E%E7%AB%AF/NodeJs/"},{"name":"源码分析","slug":"程序世界/WEB前端/源码分析","link":"/categories/%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C/WEB%E5%89%8D%E7%AB%AF/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"JavaScript","slug":"程序世界/WEB前端/JavaScript","link":"/categories/%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C/WEB%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"音乐作品","slug":"音乐世界/音乐作品","link":"/categories/%E9%9F%B3%E4%B9%90%E4%B8%96%E7%95%8C/%E9%9F%B3%E4%B9%90%E4%BD%9C%E5%93%81/"},{"name":"音乐杂谈","slug":"音乐世界/音乐杂谈","link":"/categories/%E9%9F%B3%E4%B9%90%E4%B8%96%E7%95%8C/%E9%9F%B3%E4%B9%90%E6%9D%82%E8%B0%88/"},{"name":"TypeScript","slug":"程序世界/WEB后端/NodeJs/TypeScript","link":"/categories/%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C/WEB%E5%90%8E%E7%AB%AF/NodeJs/TypeScript/"}]}